${inputFile:Chapters/navigation.pillar}$

!Turning the script into a real parser
@sec:grammar

Once you decide to extend the grammar, it is inconvenient to keep it in a script. 
It is a good practice to define a proper parser, because it allows us to
manage cyclic dependencies, 
simplify testing and 
extend with new functionality. 

!!!Hands On
We create a parser by subclassing ==PP2CompositeNode==:

[[[eval=true
stream 
	nextPutAll: '[[[';
	lf;
	nextPutAll: (PP2Tutorial new definitionFor: WebGrammar);
	lf;
	nextPutAll: ']]]'
]]]

We define a ==javascipt== rule as follows:

[[[eval=true
| t |
t := PP2Tutorial new.
t printAsCode: (t sourceFor: #javascript in: WebGrammar) stream: stream.
]]]

The rules of ==javascript== are defined as follows:
[[[eval=true
| t |
t := PP2Tutorial new.
stream 
	nextPutAll: '[[['; 
	lf;
	nextPutAll: (t sourceFor: #jsOpen in: WebGrammar);
	lf;
	lf;
	nextPutAll: (t sourceFor: #jsClose in: WebGrammar);
	lf;
	lf;
	nextPutAll: (t sourceFor: #jsContent in: WebGrammar);
	lf;
	lf;
	nextPutAll: (t sourceFor: #jsString in: WebGrammar);
	lf;
	nextPutAll: (t sourceFor: #any in: WebGrammar);
	lf;
	nextPutAll: ']]]'
]]]

First, we would like to cover ==javascript== rule with some test to make sure the rule works as expected. 
We start by subclassing ==PP2CompositeParserTest==:

[[[eval=true
| t |
t := PP2Tutorial new.
stream 
	nextPutAll: '[[[';
	lf;
	nextPutAll: (t definitionFor: WebGrammarTest);
	lf;
	lf;
	nextPutAll: (t sourceFor: #parserClass in: WebGrammarTest);
	lf;
	lf;
	nextPutAll: (t sourceFor: #testJavascript in: WebGrammarTest);
	lf;
	nextPutAll: ']]]'
]]]

To extract a javascript from an html document, we first define the ==document== rule simply as ==javascript== because we are interested only in javascript:

[[[eval=true
| t |
t := PP2Tutorial new.
t printAsCode: (t sourceFor: #document in: WebGrammar) stream: stream.
]]]

Or alternatively:
[[[
WebGrammar>>document
	^ javascript islandInSea star
]]]

The ==islandInSea== operator is a shorthand for:
[[[
sea ==> #second
]]]

We should not forget the ==start== rule:
[[[eval=true
| t |
t := PP2Tutorial new.
t printAsCode: (t sourceFor: #start in: WebGrammar) stream: stream.
]]]

And finally, we write a test for ==document==:

[[[eval=true
| t |
t := PP2Tutorial new.
t printAsCode: (t sourceFor: #testDocument in: WebGrammarTest) stream: stream.
]]]

[[[eval=true
('build/WebGrammar.st' asFileReference) deleteIfAbsent: nil.
('build/WebGrammarTest.st' asFileReference) deleteIfAbsent: nil.
WebGrammar fileOut.
WebGrammarTest fileOut.
'WebGrammar.st' asFileReference moveTo: ('build/WebGrammar.st' asFileReference).
'WebGrammarTest.st' asFileReference moveTo: ('build/WebGrammarTest.st' asFileReference).
]]]

You can download the sources here:
- *==WebGrammar==>../WebGrammar.st* 
- *==WebGrammarTest==>../WebGrammarTest.st*
