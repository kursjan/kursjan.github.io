${inputFile:Chapters/navigation.pillar}$

!Create an Abstract Syntax Tree

In the previous chapter we tested that our grammar parses the nested elements,
but we have wery bad idea how does the extracted structure looks like.
The output of a parser is typically very detailed and not well readable concrete syntax tree, which is (in the case of PetitParser) array of arrays of arrays with characters and strings as terminals.

It is the time to return a more convenient representation of the input: ''an abstract syntax tree'', in short AST. 
Abstract syntax tree, contrary to the very low-level and detailed array of arrays, so called concrete syntax tree (CST), contains information closer to the target domain. 
In our case the domain should be some kind of a javascript and html representation.

!!Testing First

It is considered to be a good practice in PetitParser to split grammar, which returns concrete syntax tree, from parser, which returns abstract syntax tree. 
We do this by subclassing ==WebGrammar==:

[[[eval=true
| t |
t := PP2Tutorial new.
stream 
	nextPutAll: '[[[';
	lf;
	nextPutAll: (t definitionFor: WebParser);
	lf;
	nextPutAll: ']]]'
]]]

Parsing is great use case for test driven development. 
If you made it so far, you probably mean it with parsing.
So let us abandon on a totorial-friendly mode and do the development the recommended way:
''start with tests''. 

Tests give us a clear idea what kind of interface do we expect from our abstract syntax tree:

[[[eval=true
| t |
t := PP2Tutorial new.
stream 
	nextPutAll: '[[['; lf;
	nextPutAll: (t definitionFor: WebParserTest); lf;
	nextPutAll: (t sourceFor: #parserClass in: WebParserTest); lf;
	lf;
	nextPutAll: (t sourceFor: #testElement in: WebParserTest); lf;
	lf;
	nextPutAll: (t sourceFor: #testElementEmpty in: WebParserTest); lf;
	lf;
	nextPutAll: (t sourceFor: #testElementNested in: WebParserTest); lf;
	lf;
	nextPutAll: ']]]'
]]]


And for malformed elements, we expect the following results:

[[[eval=true
| t |
t := PP2Tutorial new.
stream 
	nextPutAll: '[[['; lf;
	nextPutAll: (t sourceFor: #testElementMalformedExtraClose in: WebParserTest); lf;
	lf;
	nextPutAll: (t sourceFor: #testElementMalformedWrongClose in: WebParserTest); lf;
	lf;
	nextPutAll: (t sourceFor: #testElementMalformedUnclosed in: WebParserTest); lf;
	lf;
	nextPutAll: ']]]'
]]]


And of course, we expect javascript code to be extracted as follows:

[[[eval=true
| t |
t := PP2Tutorial new.
stream 
	nextPutAll: '[[['; lf;
	nextPutAll: (t sourceFor: #testJavascript in: WebParserTest); lf;
	lf;
	nextPutAll: (t sourceFor: #testJavascriptWithString in: WebParserTest); lf;
	lf;
	nextPutAll: ']]]'
]]]

!!AST Nodes
If we want to pass these test, the result of a parse should be a tree consisting of three different nodes: 
# an html element 
# a javascript code and 
# a text

We define these nodes as follows, starting with its abstract predecessor ==WebElement==, which contains only convinience methods.

[[[eval=true
| t |
t := PP2Tutorial new.
stream 
	nextPutAll: '[[['; lf;
	nextPutAll: (t definitionFor: WebElement); lf;
	lf;
	nextPutAll: (t sourceFor: #children in: WebElement); lf;
	lf;
	nextPutAll: (t sourceFor: #firstChild in: WebElement); lf;
	lf;
	nextPutAll: (t sourceFor: #secondChild in: WebElement); lf;
	lf;
	nextPutAll: (t sourceFor: #gtTreeViewIn: in: WebElement); lf;
	lf;
	nextPutAll: ']]]'
]]]

==HtmlElement== follows:

[[[eval=true
| t |
t := PP2Tutorial new.
stream 
	nextPutAll: '[[['; lf;
	nextPutAll: (t definitionFor: HtmlElement); lf;
	lf;
	nextPutAll: (t sourceFor: #children in: HtmlElement); lf;
	lf;
	nextPutAll: (t sourceFor: #name in: HtmlElement); lf;
	lf;
	nextPutAll: (t sourceFor: #name: in: HtmlElement); lf;
	lf;
	nextPutAll: (t sourceFor: #displayText in: HtmlElement); lf;
	lf;
	nextPutAll: ']]]'
]]]


As well as ==UnknownText==:

[[[eval=true
| t |
t := PP2Tutorial new.
stream 
	nextPutAll: '[[['; lf;
	nextPutAll: (t definitionFor: UnknownText); lf;
	lf;
	nextPutAll: (t sourceFor: #text in: UnknownText); lf;
	lf;
	nextPutAll: (t sourceFor: #text: in: UnknownText); lf;
	lf;
	nextPutAll: (t sourceFor: #gtText: in: UnknownText); lf;
	lf;
	nextPutAll: ']]]'
]]]


Last but not least there is ==JavascriptElement==:

[[[eval=true
| t |
t := PP2Tutorial new.
stream 
	nextPutAll: '[[['; lf;
	nextPutAll: (t definitionFor: JavascriptElement); lf;
	lf;
	nextPutAll: (t sourceFor: #code in: JavascriptElement); lf;
	lf;
	nextPutAll: (t sourceFor: #code: in: JavascriptElement); lf;
	lf;
	nextPutAll: (t sourceFor: #displayText in: JavascriptElement); lf;
	lf;
	nextPutAll: (t sourceFor: #gtText: in: JavascriptElement); lf;
	lf;
	nextPutAll: ']]]'
]]]

!!From Grammar to Parser

Now we override the rules in ==WebParser==, so that the ==javascript== rule returns ==JavascriptElement==, the ==element== rule returns ==HtmlElement== and the ==text== rule returns ==UnknownText==:


[[[eval=true
| t |
t := PP2Tutorial new.
stream 
	nextPutAll: '[[['; lf;
	nextPutAll: (t sourceFor: #javascript in: WebParser); lf;
	lf;
	nextPutAll: (t sourceFor: #element in: WebParser); lf;
	lf;
	nextPutAll: (t sourceFor: #text in: WebParser); lf;
	lf;
	nextPutAll: ']]]'
]]]

And finally, for convenience, we trim whitespaces around html elements:

[[[eval=true
| t |
t := PP2Tutorial new.
stream 
	nextPutAll: '[[['; lf;
	nextPutAll: (t sourceFor: #elClose in: WebParser); lf;
	lf;
	nextPutAll: (t sourceFor: #elOpen in: WebParser); lf;
	lf;
	nextPutAll: ']]]'
]]]

@@todo TODO: explain there is ==trimRight== so that the caching is more efficient

By this time all the tests should pass:

[[[eval=true
| t |
t := PP2Tutorial new.
stream 
	nextPutAll: '[[['; lf;
	nextPutAll: (t testResultsFor: #(
		#testElement
		#testElementEmpty
		#testElementNested
		#testElementMalformedUnclosed
		#testElementMalformedExtraClose
		#testElementMalformedWrongClose
		#testJavascript
		#testJavascriptWithString) in: WebParserTest); lf;
	lf;
	nextPutAll: ']]]'
]]]

!!Structured Document

Now the whole HTML document.
The pieces should be there, we need to connect them.
Of course, we write tests first:


[[[eval=true
| t |
t := PP2Tutorial new.
stream 
	nextPutAll: '[[['; lf;
	nextPutAll: (t sourceFor: #testStructuredDocument in: WebGrammar); lf;
	lf;
	nextPutAll: (t sourceFor: #testStructuredDocumentWithDoctype in: WebGrammar); lf;
	lf;
	nextPutAll: ']]]'
]]]

[[[
WebGrammarTest>>testStructuredDocument
	| input |
	input := '<html>
		<body>
			<script type="text/javascript">alert("hello world")</script>
		</body>
	</html>'.
	
	self parse: input rule: #structuredDocument

WebGrammarTest>>testStructuredDocumentWithDoctype
	| input |
	input := '
<!DOCTYPE html>
<!-- comment -->
<html>
	<meta content="origin" name="referrer">


	<body>
		<script type="text/javascript">alert("hello world")</script>
	</body>
</html>'.
	
	self parse: input rule: #structuredDocument
]]]

We defined document in ==WebGrammar== as a repetition of javascript seas. 
Now we define structured document, i.e. a document with an html structure. 
The root of an html file is an element that can be surrounded by some other information (e.g. doctype or comments), therefore we define it as sea:

[[[eval=true
| t |
t := PP2Tutorial new.
stream 
	nextPutAll: '[[['; lf;
	nextPutAll: (t sourceFor: #structuredDocument in: WebGrammar); lf;
	nextPutAll: ']]]'
]]]





We create a root element from the structured document:

[[[
WebParser>>structuredDocument
	^ super structuredDocument
	
	map: [ :_bw :_document :_aw |
		| beforeWater afterWater |
		beforeWater := UnknownText new
			text: _bw;
			yourself.
			
		afterWater := UnknownText new
			text: _aw;
			yourself.
			
		HtmlElement new
			name: 'DOCUMENT';
			children: (Array with: beforeWater 
					 with: _document 
					 with: afterWater);
			yourself
	
	]
]]]

And we cover the rule with a test:

[[[
WebParserTest>>testStructuredDocument
	| html |
	super testStructuredDocument.
	
	self assert: result name equals: 'DOCUMENT'.


	html := result secondChild.
	self assert: html name equals: 'html'.


	self assert: html firstChild name equals: 'head'.	
	self assert: html secondChild name equals: 'body'.
]]]

!!Comments

In this section we focus a bit more how to handle comments. They may contain scripts or other elements and they may confuse the parser. 
Actually this is happening in ==WebParser==, which extracts one element that is not in the HTML. Inspect the following and switch to the tree view:

[[[
WebParser new parse: input.
]]]

There is a ''<p>'' element in the ''<body>''. 
But ''<p>'' is a part of comment, it should not be included in the document structure. 
We write a test to cover this:

[[[
WebParserTest>>testStructuredDocument
	| html |
	super testStructuredDocument.
	
	self assert: result name equals: 'DOCUMENT'.

	html := result secondChild.
	self assert: html name equals: 'html'.

	self assert: html firstChild name equals: 'head'.	
	self assert: html secondChild name equals: 'body'.

	body := html secondChild.
	self assert: body children size equals: 4.
]]]

The problem is, as in the case of prematurely ended javascript, that our parser has no notion of a comment and handles a content of comment as an ordinary html code. 
Therefore we define what is an html comment:

[[[
WebGrammar>>comment
	^ '<!--' asPParser, #any asPParser starLazy, '-->' asPParser
]]]

And now we can redefine ==text== so that it knows what is a comment:

[[[
WebGrammar>>text
	^ (comment / #any asPParser) starLazy
]]]

We already mentioned in the previous text that ==starLazy== utilizes bounded seas and the above code is equivalent to:

[[[
(#epsilon asPParser)
  waterToken: (comment / #any asPParser);
  yourself	 
]]]


Because now water knows what is a comment, it skips the complete comment including the ''<p>'' element inside.


This is it. 
Your tests are passing right now.
