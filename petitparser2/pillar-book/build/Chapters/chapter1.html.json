{"content":"<a id=\"top\"></a>\n<p>\nThis text is part of the <a href=\"Chapters/../../book.html\">Parsing With PetitParser2</a> series.\nThe <a href=\"#toc\">table of content</a> can be found at the end of the chapter.\n\n</p>\n<section>\n<h1>Extracting Javascript</h1>\n<a id=\"sec:scripting\"></a>\n<p>\nIn this chapter we extract javascript from html files.\nThe solution provided in this chapter is a simple script.\nWe create the real parser <a href=\"chapter2.html\">later</a>.\n</p>\n<section>\n<h3>Installation</h3>\n<p>\nThe easiest way to start this tutorial is to use <a href=\"http://moosetechnology.org\">Moose</a>. \nMoose is a software and data analysis platform that has everything we need already installed.\n</p>\n<p>\nAlternatively, you can download clean <a href=\"http://pharo.org\">Pharo 6</a> (or higher) image and install PetitParser2 using the following command:\n</p>\n<figure><pre><code class=\"smalltalk\">Metacello new\n\tbaseline: 'PetitParser2';\n\trepository: 'github://kursjan/petitparser2';\n   \tload</code></pre><figcaption></figcaption></figure>\n\n<p>\nIn case nothing of the previous works, please <a href=\"mailto:kurs.jan@gmail.com\">let us know</a>. \n</p>\n\n</section><section>\n<h3>Hands On</h3>\n<p>\nOpen your playground and let's start coding. \nFirst of all, we define what we want to parse:\n</p>\n<figure><pre><code class=\"smalltalk\">source := PP2Sources current htmlSample.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe source very simplified (and slightly modified) version of <a href=\"wikipedia.org\">Wikipedia</a> and contains the following text:\n</p><figure><pre><code class=\"smalltalk\">&lt;!DOCTYPE html&gt;\n&lt;!-- saved from url=(0026)https://www.wikipedia.org/ --&gt;\n&lt;html lang=&quot;mul&quot; dir=&quot;ltr&quot; class=&quot;js-enabled&quot;&gt;\n&lt;head&gt;\n\t&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;\n\t&lt;title&gt;Wikipedia&lt;/title&gt;\n\t&lt;meta name=&quot;description&quot; content=&quot;Wikipedia is a free online encyclopedia, created and edited by volunteers around the world and hosted by the Wikimedia Foundation.&quot;&gt;\n\t&lt;!--[if gt IE 7]--&gt;\n\t&lt;script&gt;document.documentElement.className = document.documentElement.className.replace( /(^|\\s)no-js(\\s|$)/, &quot;$1js-enabled$2&quot; );&lt;/script&gt;\n\t&lt;!--[endif]--&gt;\n&lt;/head&gt;\n&lt;body id=&quot;www-wikipedia-org&quot;&gt;\n\t&lt;h1 class=&quot;central-textlogo&quot; style=&quot;font-variant: small-caps&quot; alt=&quot;WikipediA&quot; title=&quot;Wikipedia&quot;&gt;\n\t\t&lt;img src=&quot;./Wikipedia_files/Wikipedia_wordmark.png&quot; srcset=&quot;portal/wikipedia.org/assets/img/Wikipedia_wordmark@1.5x.png 1.5x&quot; width=&quot;174&quot; height=&quot;30&quot; alt=&quot;WikipediA&quot; title=&quot;Wikipedia&quot;&gt;\n\t\t&lt;strong id=&quot;js-localized-slogan&quot; class=&quot;localized-slogan&quot; style=&quot;visibility: visible;&quot;&gt;The Free Encyclopedia&lt;/strong&gt;\n\t&lt;/h1&gt;\n\t&lt;div id=&quot;mydiv&quot;&gt;\n\t\tHi there!\n\t&lt;/div&gt;\n\t&lt;script&gt;alert(&quot;All scripts ends with: '&lt;/script&gt;'...&quot;)&lt;/script&gt;\n\t&lt;!-- &lt;p&gt;obsolete conentent&lt;/p&gt; --&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><figcaption></figcaption></figure>\n\n<p>\nSecond, we define javascript as a <code>js</code> rule:\n</p>\n<figure><pre><code class=\"smalltalk\">js := '&lt;script&gt;' asPParser, #any asPParser starLazy flatten, '&lt;/script&gt;' asPParser \n\t==&gt; #second.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe <code>starLazy</code> operator is a new feature of PetitParser2.<sup><a href=\"#footnote1\">[1]</a></sup>\nIt repetitively invokes the given parser (any character in this case) until a string recognized by the following parser appears. \nWhat makes <code>starLazy</code> useful is that you donâ€™t need to specify what is the following parser, it is inferred automatically based on the grammar specification. \nOf course, with any change in the grammar, the <code>starLazy</code> updates itself.\nIf you want to define the same rule in PetitParser, it would be:\n</p>\n<figure><pre><code class=\"smalltalk\">#any asParser starLazy: '&lt;script&gt;' asParser.</code></pre><figcaption></figcaption></figure>\n\n<p>\nIn order to extract the javascript itself and throw away the begin and end tags, we use \n</p>\n<figure><pre><code class=\"smalltalk\">==&gt; #second</code></pre><figcaption></figcaption></figure>\n\n<p>\nLet us try if the javascript rule can parse our <code>source</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">js parse: source.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe result is failure. \nIf we inspect the failure object and switch to <em>Debug View</em> we notice that <em>&lt;script&gt;</em> is expected at the beginning of a file, yet our input starts with <em>&lt;!DOCTYPE html&gt;</em>. \nThe fix to this is simple: we create a new rule <code>jsSea</code> as a javascript island in a sea of an uninteresting water:\n</p>\n<figure><pre><code class=\"smalltalk\">jsSea := js sea.\njsSea parse: source.</code></pre><figcaption></figcaption></figure>\n\n<p>\nGood, the result is not failure! \nBut it is not exactly what we want neither. \nSea returns an array of three elements: \n</p><ol><li>before-water </li>\n<li>island and </li>\n<li>after-water</li>\n</ol>\n<p>\nIsland is the result of the javascript rule, before and after water contain the rest of an input. We are interested only in the the javascript, so we redefine the document rule as follows:\n</p>\n\n<figure><pre><code class=\"smalltalk\">jsSea := js sea ==&gt; #second.\njsSea parse: source.</code></pre><figcaption></figcaption></figure>\n\n<p>\nLooks better, but we are missing some results! \nThis is because we never specified that there could be multiple occurrences of <code>jsSea</code>. \nTherefore the sea rule finds only one --- the first one. \nWe can easily add more <code>jsSea</code> rules by defining a <code>document</code> rule:\n</p>\n<figure><pre><code class=\"smalltalk\">document := jsSea star.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe whole script looks like: \n</p><figure><pre><code class=\"smalltalk\">source := PP2Sources current htmlSample.\njs := '&lt;script&gt;' asPParser, #any asPParser starLazy flatten, '&lt;/script&gt;' asPParser\n\t==&gt; #second.\njsSea := js sea ==&gt; #second.\ndocument := jsSea star.</code></pre><figcaption></figcaption></figure>\n\n<p>\nNow by calling <code>document parse: source</code> we extract both javascripts from the source, the result should look like: \n</p>\n<figure><pre><code class=\"javascript\">document.documentElement.className = document.documentElement.className.replace( /(^|\\s)no-js(\\s|$)/, &quot;$1js-enabled$2&quot; );\n\nalert(&quot;All scripts ends with: '</code></pre><figcaption></figcaption></figure>\n\n<p>\nYet, there is something fishy about the second result. \nThe second javascript ended prematurely!\nIt should look like this:\n</p><figure><pre><code class=\"javascript\">alert(&quot;All scripts ends with: '&lt;/script&gt;'...&quot;)</code></pre><figcaption></figcaption></figure>\n\n<p>\nIt is prematurely ended, because the javascript rule as we defined it does not know about strings. \nTherefore, the javascript rule thinks that there is a closing of the script tag even though it is a part of the alert message string. \nWe fix it by defining javascript strings and redefining the <code>js</code> rule:\n</p>\n<figure><pre><code class=\"smalltalk\">any := #any asPParser.\njsString := $' asPParser, any starLazy, $' asPParser.\njs := '&lt;script&gt;' asPParser, ((jsString / any) starLazy) flatten, '&lt;/script&gt;' asPParser\n\t ==&gt; #second.\n\njsSea := js sea ==&gt; #second.\ndocument := jsSea star.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe result looks better now:\n</p>\n<figure><pre><code class=\"javascript\">document.documentElement.className = document.documentElement.className.replace( /(^|\\s)no-js(\\s|$)/, &quot;$1js-enabled$2&quot; );\n\nalert(&quot;All scripts ends with: '&lt;/script&gt;'...&quot;)</code></pre><figcaption></figcaption></figure>\n\n<p>\nGreat, everything works as expected!\n</p>\n</section></section><section>\n<h1>Conclusion</h1>\n<p>\nIn this part, we have quickly prototyped a parser to extract javascript from html files.\nContrary to the first version of PetitParser, we could utilize bounded seas and <code>starLazy</code> operator, which skip an uninteresting input without us specifying how to skip it. \n</p>\n<p>\nIf you think that such a task could be done using regular expression you are right.\nBut contrary to regular expressions, this is just a first step for PetitParser, which will boldly go where no regular expression has gone before.\n</p>\n\n<a id=\"toc\"></a><section>\n<h1>Table of Contents</h1>\n<p>\nThis text is part of the <a href=\"Chapters/../../book.html\">Parsing With PetitParser2</a> series.\n</p>\n<p>\nPart I, Basics:\n</p><ul>\n<li><a href=\"Chapters/../chapter1.html\">Extracting Javascript</a></li>\n<li><a href=\"Chapters/../chapter2.html\">From Script to Parser</a></li>\n<li><a href=\"Chapters/../chapter3.html\">Extracting the Structure</a></li>\n<li><a href=\"Chapters/../AST.html\">Abstract Syntax Tree</a></li>\n<li><a href=\"Chapters/../optimizations.html\">Optimizations</a></li>\n<li><a href=\"Chapters/../memoization.html\">Memoization</a></li>\n</ul>\n\n<p>\nPart II, Advanced Topics:\n</p><ul>\n<li><a href=\"Chapters/../starLazy.html\">The <code>starLazy</code> Operator</a></li>\n<li><a href=\"Chapters/../matchingTags.html\">Matching Tags</a></li>\n<li><a href=\"Chapters/../smalltalkOptimization.html\">Specializations in Detail</a></li>\n<li><a href=\"Chapters/../caches.html\">Caches in Detail</a></li>\n</ul>\n\n<p>\nGo to <a href=\"#top\">top</a>.\n</p></section></section>\n<hr></hr>\n<sup id=\"footnote1\">[1]  It is build on top of bounded seas, but we will talk about this in more detail later.</sup><br/>\n","title":"Parsing with PetitParser2","Author":"Jan Kurs"}