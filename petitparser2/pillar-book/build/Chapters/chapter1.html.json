{"content":"<p>\nThis text is part of the PetitParser2 series:\n</p><ul>\n<li><a href=\"Chapters/../chapter1.html\">Extracting Javascript</a></li>\n<li><a href=\"Chapters/../chapter2.html\">From Script to Parser</a></li>\n<li><a href=\"Chapters/../chapter3.html\">Extracting Structure</a></li>\n<li><a href=\"Chapters/../chapter4.html\">Optimizations</a></li>\n<li><a href=\"Chapters/../chapter5.html\">Memoization</a></li>\n</ul>\n\n<section>\n<h1>Extracting Javascript</h1>\n<a id=\"sec:scripting\"></a>\n<p>\nIn this chapter we extract javascript from html files.\nThe solution provided in this chapter is a simple script.\nWe create the real parser <a href=\"chapter2.html\">later</a>.\n</p>\n<section>\n<h3>Installation</h3>\n<p>\nThe easiest way to start this tutorial is to use <a href=\"http://moosetechnology.org\">Moose</a>. \nMoose is a software and data analysis platform that has everything we need already installed.\n</p>\n<p>\nAlternatively, you can download clean <a href=\"http://pharo.org\">Pharo 6</a> (or higher) image and install PetitParser2 using the following command:\n</p>\n<figure><pre><code class=\"smalltalk\">Metacello new\n\tbaseline: 'PetitParser2';\n\trepository: 'github://kursjan/petitparser2';\n   \tload</code></pre><figcaption></figcaption></figure>\n\n</section><section>\n<h3>Hands On</h3>\n<p>\nOpen your playground and let's start coding. \nFirst of all, we define what we want to parse:\n</p>\n<figure><pre><code class=\"smalltalk\">source := PP2Sources current htmlSample.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe source is based on the HMTL of <a href=\"wikipedia.org\">Wikipedia</a> and contains the following text:\n</p><figure><pre><code class=\"smalltalk\">&lt;!DOCTYPE html&gt;\n&lt;!-- saved from url=(0026)https://www.wikipedia.org/ --&gt;\n&lt;html lang=&quot;mul&quot; dir=&quot;ltr&quot; class=&quot;js-enabled&quot;&gt;\n&lt;head&gt;\n\t&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;\n\t&lt;title&gt;Wikipedia&lt;/title&gt;\n\t&lt;meta name=&quot;description&quot; content=&quot;Wikipedia is a free online encyclopedia, created and edited by volunteers around the world and hosted by the Wikimedia Foundation.&quot;&gt;\n\t&lt;!--[if gt IE 7]--&gt;\n\t&lt;script&gt;document.documentElement.className = document.documentElement.className.replace( /(^|\\s)no-js(\\s|$)/, &quot;$1js-enabled$2&quot; );&lt;/script&gt;\n\t&lt;!--[endif]--&gt;\n&lt;/head&gt;\n&lt;body id=&quot;www-wikipedia-org&quot;&gt;\n\t&lt;h1 class=&quot;central-textlogo&quot; style=&quot;font-variant: small-caps&quot; alt=&quot;WikipediA&quot; title=&quot;Wikipedia&quot;&gt;\n\t\t&lt;img src=&quot;./Wikipedia_files/Wikipedia_wordmark.png&quot; srcset=&quot;portal/wikipedia.org/assets/img/Wikipedia_wordmark@1.5x.png 1.5x&quot; width=&quot;174&quot; height=&quot;30&quot; alt=&quot;WikipediA&quot; title=&quot;Wikipedia&quot;&gt;\n\t\t&lt;strong id=&quot;js-localized-slogan&quot; class=&quot;localized-slogan&quot; style=&quot;visibility: visible;&quot;&gt;The Free Encyclopedia&lt;/strong&gt;\n\t&lt;/h1&gt;\n\t&lt;div id=&quot;mydiv&quot;&gt;\n\t\tHi there!\n\t&lt;/div&gt;\n\t&lt;script&gt;alert(&quot;All scripts ends with: '&lt;/script&gt;'...&quot;)&lt;/script&gt;\n\t&lt;!-- &lt;p&gt;obsolete conentent&lt;/p&gt; --&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><figcaption></figcaption></figure>\n\n<p>\nSecond, we define javascript as a <code>js</code> rule:\n</p>\n<figure><pre><code class=\"smalltalk\">js := '&lt;script&gt;' asPParser, #any asPParser starLazy flatten, '&lt;/script&gt;' asPParser \n\t==&gt; #second.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe <code>starLazy</code> operator is a new feature of PetitParser2 and it is build on top of bounded seas. \nIt repetitively invokes the given given parser (any character in this case) until a string recognized by the following parser appears. \nWhat makes it convenient is that you don’t need to specify what is the following parser, it is inferred automatically based on the grammar specification. \nIf you want to define the same rule in PetitParser, it would be:\n</p>\n<figure><pre><code class=\"smalltalk\">#any asParser starLazy: ‘&lt;script&gt;’ asParser.</code></pre><figcaption></figcaption></figure>\n\n<p>\nIn order to extract the javascript itself and throw away the begin and end tags, we use \n</p>\n<figure><pre><code class=\"smalltalk\">==&gt; #second</code></pre><figcaption></figcaption></figure>\n\n<p>\nLet us try if the javascript rule can parse our <code>source</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">js parse: source.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe result is failure. \nIf we inspect the failure object and switch to <em>Debug View</em> we notice that <em>&lt;script&gt;</em> is expected at the beginning of a file, yet our input starts with <em>&lt;!DOCTYPE html&gt;</em>. \nThe fix to this is simple: we create a new rule <code>jsSea</code> as a javascript island in a sea of an uninteresting water:\n</p>\n<figure><pre><code class=\"smalltalk\">jsSea := js sea.\njsSea parse: source.</code></pre><figcaption></figcaption></figure>\n\n<p>\nGood, the result is not failure! \nBut it is not exactly what we want neither. \nSea returns an array of three elements: \n</p><ol><li>before-water </li>\n<li>island and </li>\n<li>after-water</li>\n</ol>\n<p>\nIsland is the result of the javascript rule, before and after water contain the rest of an input. We are interested only in the the javascript, so we redefine the document rule as follows:\n</p>\n<figure><pre><code class=\"smalltalk\">jsSea := js sea ==&gt; #second.\njsSea parse: source.</code></pre><figcaption></figcaption></figure>\n\n<p>\nLooks better, but we are missing some results! \nThis is because we never specified that there could be multiple occurrences of <code>jsSea</code>. \nTherefore the sea rule finds only one --- the first one. \nWe can easily add more <code>jsSea</code> rules by defining a <code>document</code> rule:\n</p>\n<figure><pre><code class=\"smalltalk\">document := jsSea star.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe whole script looks like: \n</p><figure><pre><code class=\"smalltalk\">source := PP2Sources current htmlSample.\njs := '&lt;script&gt;' asPParser, #any asPParser starLazy flatten, '&lt;/script&gt;' asPParser\n\t==&gt; #second.\njsSea := js sea ==&gt; #second.\ndocument := jsSea star.</code></pre><figcaption></figcaption></figure>\n\n<p>\nNow by calling <code>document parse: source</code> we extract both scripts, the result should look like: \n</p>\n<figure><pre><code class=\"javascript\">document.documentElement.className = document.documentElement.className.replace( /(^|\\s)no-js(\\s|$)/, &quot;$1js-enabled$2&quot; );\nalert(&quot;All scripts ends with: '</code></pre><figcaption></figcaption></figure>\n\n<p>\nYet, there is something fishy about the second result. \nThe second javascript is has ended prematurely! \nIt is because the javascript rule as we defined it does not know about strings. \nTherefore, the javascript rule thinks that there is a closing of the script tag even though it is a part of the alert message string. \nWe fix it by defining javascript strings and redefining the <code>js</code> rule:\n</p>\n<figure><pre><code class=\"smalltalk\">jsString := $' asPParser, #any asPParser starLazy, $' asPParser.\nany := #any asPParser.\njs := '&lt;script&gt;' asPParser, ((jsString / any) starLazy) flatten, '&lt;/script&gt;' asPParser\n\t ==&gt; #second.\n\njsSea := js sea ==&gt; #second.\ndocument := jsSea star.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe result looks better now:\n</p>\n<figure><pre><code class=\"javascript\">document.documentElement.className = document.documentElement.className.replace( /(^|\\s)no-js(\\s|$)/, &quot;$1js-enabled$2&quot; );\nalert(&quot;All scripts ends with: '&lt;/script&gt;'...&quot;)</code></pre><figcaption></figcaption></figure>\n\n<p>\nGreat, everything works as expected!\n</p>\n</section><section>\n<h3>StarLazy </h3>\n<p>\nIn this section, we shortly inspect how does the <code>startLazy</code> operator works. \nThe code  parser <code>starLazy</code> is a shorthand for the following:\n</p>\n<figure><pre><code class=\"smalltalk\">^ (#epsilon asPParser sea)\n\twaterToken: parser;\n\tyourself</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe island of the sea is <code>#epsilon</code>. \nSuch an island will always be found, because it accepts an empty string. \nFurthermore it will be surrounded by water that consumes anything until the next parser succeeds. \nYou specify contents of a water by setting the <code>waterToken</code>. \nBy default you can use <code>#any asPParser</code>. \nThis means that the sea moves character by character betwen tests when to stop. \n</p>\n<p>\nYet as we have seen in the case of the <code>javascript</code> rule, invoking <code>#any asPParser</code> may not be sufficient, the water can get confused by an end tag hidden in a string. \nTherefore, bounded seas allow you to define tokens that are expected in water. \nSuch token can be a string or a comment and thus does not confuse the parser. \nIn our case the tokens are either <code>jsString</code> or any character:\n</p>\n<figure><pre><code class=\"smalltalk\">^ (#epsilon asPParser sea)\n\twaterToken: jsString / #any asPParser;\n\tflatten</code></pre><figcaption></figcaption></figure>\n\n<p>\nWe have missed one detail.\nThe actual implementation of <code>starLazy</code> actually extracts only before water:\n</p><figure><pre><code class=\"smalltalk\">PP2Node&gt;&gt;starLazy\n\t^ ((#epsilon asPParser sea)\n\t\twaterToken: self)\n\tmap: [:_before :_epsilon :_after | \n\t\t&quot;return just before water, because island is nil and after water is empty&quot;\n\t\t_before\n\t] </code></pre><figcaption></figcaption></figure>\n\n<p>\nIf your island is parse an empty string (e.g. island is optional, zero or more repetitions or simply epsilon), seas postpone the epsilon parse as far as possible, until the boundary is found.\nTherefore, in case of <code>starLazy</code>, all the consumed input is in the before water and after water is empty.\n\n</p></section></section>","title":"PetitParser2 and Bounded Seas","Author":"Jan Kurs"}