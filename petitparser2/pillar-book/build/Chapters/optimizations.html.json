{"content":"<a id=\"top\"></a>\n<p>\nThis text is part of the <a href=\"Chapters/../../book.html\">Parsing With PetitParser2</a> series.\nThe <a href=\"#toc\">table of content</a> can be found at the end of the chapter.\n\n</p>\n<section>\n<h1>Optimizations Overview</h1>\n\n<p class=\"note\">Please note that the <code>WebGrammar</code> you could download in the <a href=\"AST.html\">Abstract Syntax Tree</a> chapter contains already optimized version of an <code>element</code> rule. In this chapter we suppose that <code>element</code> definition looks like defined in <a href=\"chapter3.html\">Extracting the Structure</a> chapter, i.e. it looks like this:</p><figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;element\n\t^ (elOpen, elContent, elClose)</code></pre><figcaption></figcaption></figure>\n\n<section>\n<h2>1. Basic Analysis</h2>\n<p>\nWhen running the <code>testStructuredDocument</code>, you might have noticed that the performance is not good. \nIt is actually terribly bad. Let us inspect in in detail:\n</p>\n<figure><pre><code class=\"smalltalk\">input := PP2Sources current htmlSample.\nWebParser new debug: input.</code></pre><figcaption></figcaption></figure>\n\n<section>\n<h3>Report View</h3>\n<p>\nThis will run the parser in a debug mode and collect a lot of useful information. Unfortunately, it also takes considerable amount of time so be patient. Once you get the result, inspect the <em>Report tab</em> (note that numbers might slightly differ in your case):\n</p>\n<p>\n\n<figure>\n\t<img src=\"figures/unoptimized-report.png\" width=\"100%%\"/>\n\t<figcaption>Report view of non-optimized parse</figcaption>\n</figure>\n</p>\n<p>\nThe total stream size is 1171 characters. \nThe parser has remembered the full context 510197 times and restored 387667 times. \nThis means that the full copy of the context (including the stack of opened elements) has been created 510197 times and the context has been restored from this full copy (by doing another copy) 387667 times. \nThis is in average 331 backtrackings per consumed character. \n</p>\n\n<p>\nSome of the parsers do not need to perform the full context copy. \nThese are prefixed with ‘lightweight’. \nIn the lightweight case, only the position is remembered and restored (which is much faster than the full copy of a stack). \nThis happened in average 92 times per character.\n</p>\n\n<p>\nHonestly, these numbers are brutal. \nIn ideal case, the number of full restores should be zero. \nFull remember and restore is very expensive. \nVery often only lightweight remember and restore happens, since many grammars are context-free, i.e. they do not use <code>push</code>, <code>match</code> and <code>pop</code> operators. \n</p>\n<p>\nRegarding the lightweight backtracking, the average of lightweight backtracks per character should be below 1 (in ideal case). \nThis is also not so unusual case when dealing with deterministic grammars, which do not do any (or only a little) speculations and know exactly which alternative of a choice is the correct one. \n</p>\n</section><section>\n<h3>Debug View</h3>\n<p>\nBut our grammar is obviously not deterministic it does lots of speculations.\nWhy are the numbers so bad in our case? \nLet us inspect in more detail how this was happening, using the <em>Debug view</em>:\n</p>\n<p>\n\n<figure>\n\t<img src=\"figures/unoptimized-debug.png\" width=\"100%%\"/>\n\t<figcaption>Debug View of non-optimized parse.</figcaption>\n</figure>\n</p>\n<p>\nThe view shows us that 1502165 parsers were invoked to consume the input. \nMost of it (751559 invocations) happened when parsing first two lines of the input --- the before water of the sea.\n</p>\n<p>\nThis is too much for a short input. \nSuch a bad performance is caused by the fact that bounded seas have to verify at every position if the next parser (i.e. the parser that will be invoked after the sea) will succeed. \nIf the next parser happens to be another sea (as in the case of <code>WebGrammar</code>), the number of invocations grows really fast (exponentially in fact). \n</p>\n\n<p>\nWe see that the element rule took approximately one half of the invocations (750598). \nMajority of 751559 invocations of before water were spent by testing for element. \n</p>\n<p>\nAnother glimpse of ineffectiveness can be seen in the <code>elOpen</code> rule.\n</p>\n<p>\n<a id=\"elOpenUnoptimized\"></a>\n<figure>\n\t<img src=\"figures/unoptimized-elOpen.png\" width=\"100%%\"/>\n\t<figcaption>0.1. Debug view of the <code>elOpen</code> rule non-optimized parse.</figcaption>\n</figure>\n</p>\n<p>\nYou can see that the whole <em>&lt;html lang=&quot;html&quot; dir=&quot;ltr&quot; class=&quot;js-enabled&quot;&gt;</em> is parsed by invoking 272 parsers.\nThis is quite a lot for a line with 55 characters.\nOne of the reasons is how are the identifiers (<code>elementName</code>) parsed.\nYou can see that when recognizing the <em>html</em> text, 8 different parsers are invoked; for each letter one and some extra boilerplate parsers (flattening, possessive repeating,...).\n</p>\n</section></section><section>\n<h2>2. Using the <code>optimize</code> method</h2>\n<p>\nLuckily, PetitParser2 comes with an automated optimizations that are able to reduce most of the unnecessary overhead. \nLet it give a try:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParser new optimize debug: input.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe report looks much better now:\n<a id=\"\"></a>\n<figure>\n\t<img src=\"figures/optimized-report.png\" width=\"100%%\"/>\n\t<figcaption>0.2. Report view of the optimized parse.</figcaption>\n</figure>\n</p>\n\n\n<p>\nOnly one full remember, and only 7 lightweight backtracks per character. \nThis is reasonably good for a grammar with bounded seas. \n</p>\n<p class=\"note\">Because of the nature of bounded seas and nature of PetitParser2, we do not recommend to parse grammars with more complicated bounded seas without optimizations.</p>\n<section>\n<h3>Optimization in Detail</h3>\n<p>\nLet us inspect some of the optimizations that happened. \nWe switch to <em>Debug view</em>:\n</p>\n<p>\n\n<figure>\n\t<img src=\"figures/optimized-debug.png\" width=\"100%%\"/>\n\t<figcaption></figcaption>\n</figure>\n</p>\n<p>\nWe see that the total number of invoked parsers is 55144, roughly 30x less. \nWe also see that, as in the previous case, most of the parsers are invoked in the before-water of the initial sea, but it is roughly 10x better now. \nWe can also notice that the following island and after water are parsed using only 2 and 4 parser invocations respectively.\nThis is great, it was half of the total invocations in the case of unoptimized parse!\n</p>\n</section><section>\n<h3>Caches</h3>\n\n<p>\nThe main reason of reduced invocations is caching. \nUnder the <code>element</code> rule, there is a mapping node. \nThe mapping node returns the complete HTML element just in two invocations. \nThe fact that the result has been cached is visualized via the result reference (see <code>DebugResultLink: reference</code>). \n</p>\n\n<p>\nThe reference indicates that at the time of the invocation the result has already been computed during some previous invocation. \nThe parser remembered the result and returned the remembered without invoking the parser again. \nThis work is done by the <code>PP2Cache</code> strategy (you can see its profiling version <code>PP2ProfilingCache</code> in the screenshot). \nThe cache has been added to the element during the optimization phase. \n</p>\n<p>\nMore about caches can be found in the <a href=\"caches.html\">Caching chapter</a>.\n</p>\n</section><section>\n<h3>Specializations</h3>\n\n<p>\nAnother optimizations applied by PetitParser two are specializations.\nThe way specializations work can be demonstrated on the opening of an html element: <em>&lt;html lang=&quot;mul&quot; dir=&quot;ltr&quot; class=&quot;js-enabled&quot;&gt;</em>.\n</p>\n<p>\n<a id=\"elOpenOptimized\"></a>\n<figure>\n\t<img src=\"figures/optimized-elOpen.png\" width=\"100%%\"/>\n\t<figcaption>0.3. Optimized parse of <code>elOpen</code></figcaption>\n</figure>\n</p>\n<p>\nOne can see that the <em>html</em> text has been recognized using only three invocation contrary to the eight invocations in the unoptimized case (see Figure <a href=\"#elOpenUnoptimized\">0.1</a>).\nIn the unoptimized case the <em>html</em> text was parsed using the <em>PossessiveRepeating</em> strategy.\nIn the optimized case (see Figure <a href=\"#elOpenOptimized\">0.3</a>) the used strategy is <em>PlusPredicateObject</em>, which is implemented as a while loop without superfluous parser invocations hence is more efficient.\n</p>\n<p>\nThe same thing happened with the mapping node. \nThe specializations recognized an <em>any-star-lazy</em> pattern, which, in this case, means to consume any character until end of the tag <code>&gt;</code> appears.\nThis can be implemented as a single while loop saving 252 parser invocations.\n</p>\n<p class=\"todo\">More details about specializations are provided in the <a href=\"smalltalkOptimizations.html\">Smalltalk Parser</a> chapter.</p>\n</section></section><section>\n<h2>3. Conclusion</h2>\n<p>\nOverall, PEG-based parser combinator parsers are great, they are easy to understand, easy to extend and easy to debug.\nBut this all comes at the price of inefficiency. \nYet, the optimization capabilities of PetitParser can dramatically improve the performance while preserving all the other advantages.\n</p>\n<p>\nUnfortunately, not all the optimizations can be done automatically.\nThere is one kind of optimizations that has to be done manually and we dedicate a whole <a href=\"memoization.html\">Memoization</a> chapter to it.\n</p>\n<a id=\"toc\"></a><section>\n<h1>Table of Contents</h1>\n<p>\nThis text is part of the <a href=\"Chapters/../../book.html\">Parsing With PetitParser2</a> series.\n</p>\n<p>\nPart I, Developer's Workflow:\n</p><ul>\n<li><a href=\"Chapters/../chapter1.html\">Extracting Javascript</a></li>\n<li><a href=\"Chapters/../chapter2.html\">From a Script to a Parser</a></li>\n<li><a href=\"Chapters/../chapter3.html\">Extracting the Structure</a></li>\n<li><a href=\"Chapters/../AST.html\">Abstract Syntax Tree</a></li>\n<li><a href=\"Chapters/../optimizations.html\">Optimizations</a></li>\n<li><a href=\"Chapters/../memoization.html\">Memoization</a></li>\n</ul>\n\n<p>\nPart II, Advanced Topics:\n</p><ul>\n<li><a href=\"Chapters/../starLazy.html\">The <code>starLazy</code> Operator</a></li>\n<li><a href=\"Chapters/../matchingTags.html\">Matching Tags</a></li>\n<li><a href=\"Chapters/../smalltalkOptimization.html\">Specializations in Detail</a></li>\n<li><a href=\"Chapters/../caches.html\">Caches in Detail</a></li>\n</ul>\n\n<p>\nGo to <a href=\"#top\">top</a>.\n\n</p></section></section></section>","title":"Parsing with PetitParser2","Author":"Jan Kurs"}