{"content":"<p>\nThis text is part of the <a href=\"Chapters/../../book.html\">Parsing With PetitParser2</a> series.\n</p><ul>\n<li><a href=\"Chapters/../chapter1.html\">Extracting Javascript</a></li>\n<li><a href=\"Chapters/../chapter2.html\">From Script to Parser</a></li>\n<li><a href=\"Chapters/../chapter3.html\">Extracting the Structure</a></li>\n<li><a href=\"Chapters/../AST.html\">Abstract Syntax Tree</a></li>\n<li><a href=\"Chapters/../optimizations.html\">Optimizations</a></li>\n<li><a href=\"Chapters/../memoization.html\">Memoization</a></li>\n</ul>\n\n<p>\nAdditional Chapters:\n</p><ul>\n<li><a href=\"Chapters/../matchingTags.html\">Matching Tags</a></li>\n<li><a href=\"Chapters/../smalltalkOptimization.html\">Specializations in Detail</a></li>\n<li><a href=\"Chapters/../caches.html\">Caches in Detail</a></li>\n</ul>\n\n<section>\n<h1>Matching Open And Close Tags</h1>\n\n<p>\nElements of HTML has an interesting property: the name of an opening tag has to match the name of a closing tag. \nThough natural for humans, this is, surprisingly, rather difficult task from the parsing theory point of view.\n</p>\n\n<p>\nOne of the standard solutions provided by parsing frameworks (including PetitParser) are parsing actions. \nWe define an action to assert that the name of an open tag corresponds to the name of a close tag:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;element\n\t^ elOpen, content, elClose\n\n\tmap: [:_open :_content :_close |\n\t(_open = _close) ifTrue: [\n\t\t_content\n\t] ifFalse: [ \n\t\tPP2Failure message: ‘open and close do not match’.\n\t]</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nUnfortunately, this solution has a problem with unclosed elements like these:\n</p>\n<figure><pre><code class=\"smalltalk\">&lt;b&gt;&lt;i&gt;bold and italics&lt;/b&gt;</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe first <code>elOpen</code> consumes <em>&lt;b&gt;</em>, \nthe second <code>elOpen</code> consumes \n<em>&lt;i&gt;</em>, \ncontent consumes <em>bold and italics</em> and \n<code>elClose</code> consumes <em>&lt;/b&gt;</em>. \nThe action checks if <em>i = b</em> and returns failure. \nThe failure will be the final result because such a code does not restore position to recover from the failure and actions do not offer a way to do so. \nOther options based on custom parsers or wrapping parsers will sooner or later run into a hard to debug issues with backtracking as well.\n</p>\n<p>\nThe PetitParser2 offers more formal way of such definitions. \nIt can store a result of a rule (e.g. <code>elOpen</code>) onto a stack using the push operator and assert that the result of a rule (e.g. <code>elClose</code>) matches the top of the stack using the match operator and finally pop the result using the pop operator. \nHere is the concrete example. \n</p>\n\n<p>\nFirst we define an element name as a repetition of letters and digits:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;elementName\n\t^ #word asPParser plus flatten</code></pre><figcaption></figcaption></figure>\n\n<p>\nThan we define element as a sequence of <code>elOpen</code>, <code>elContent</code> and <code>elClose</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;element\n\t^ (elOpen, elContent, elClose)</code></pre><figcaption></figcaption></figure>\n\n<p>\nIn <code>elOpen</code>, we push the element name as well as we consume water in case an element contains arguments:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;elOpen\n\t^ $&lt; asPParser, elementName push, #any starLazy, $&gt; asPParser ==&gt; #second</code></pre><figcaption></figcaption></figure>\n\n<p>\nIn <code>elClose</code>, we first match the element name against the top of a stack and we pop the stack in case of success:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;elClose\n\t^ '&lt;/' asPParser, elementName match pop, $&gt; asPParser</code></pre><figcaption></figcaption></figure>\n</section>","title":"Parsing with PetitParser2","Author":"Jan Kurs"}