{"content":"<a id=\"top\"></a>\n<p>\nThis text is part of the <a href=\"Chapters/../../book.html\">Parsing With PetitParser2</a> series.\nThe <a href=\"#toc\">table of content</a> can be found at the end of the chapter.\n\n</p>\n<section>\n<h1>Create an Abstract Syntax Tree</h1>\n\n<p>\nIn the previous chapter we tested that our grammar parses the nested elements,\nbut we have very limited idea how does the extracted structure look like.\nThe direct output of a parser is typically very detailed and not well-readable. \nIt is called concrete syntax tree (CST), which is (in the case of PetitParser) array of arrays of arrays of ... with characters and strings as terminals.\n</p>\n<p>\nIt is the time to return a more convenient representation of the input: <em>an abstract syntax tree</em>, in short AST. \nAbstract syntax tree, contrary to the very low-level and detailed concrete syntax tree, is conceptually closer to the target domain. \nIn our case the domain should be some kind of a tree with html elements and javascript.\n</p>\n\n<p>\nIt is considered to be a good practice in PetitParser to split grammar, which returns concrete syntax tree, from parser, which returns abstract syntax tree. \nWe do this by subclassing <code>WebGrammar</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar subclass: #WebParser\n\tinstanceVariableNames: ''\n\tclassVariableNames: ''\n\tpoolDictionaries: ''\n\tcategory: 'PetitParser2-Tutorial'</code></pre><figcaption></figcaption></figure>\n\n<section>\n<h2>1. Testing First</h2>\n\n<p>\nParsing is great use case for test driven development. \nSo let us start with tests first. \nTests give us a clear idea what kind of interface we expect from abstract syntax tree:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammarTest subclass: #WebParserTest\n\tuses: TPP2TypeAssertions\n\tinstanceVariableNames: ''\n\tclassVariableNames: ''\n\tpoolDictionaries: ''\n\tcategory: 'PetitParser2-Tutorial'\n\nWebParserTest&gt;&gt;parserClass\n\t^ WebParser\n\nWebParserTest&gt;&gt;testElement\n\tsuper testElement.\n\t\n\tself assert: result name equals: 'p'.\n\tself assert: result firstChild text equals: 'lorem ipsum'\n\nWebParserTest&gt;&gt;testElementEmpty\n\tsuper testElementEmpty.\n\t\n\tself assert: result name equals: 'foo'.\n\nWebParserTest&gt;&gt;testElementNested\n\tsuper testElementNested.\n\t\n\tself assert: result name equals: 'p'.\n\tself assert: result firstChild text trim equals: 'lorem'.\n\tself assert: result secondChild name equals: 'i'.\n\tself assert: result secondChild firstChild text equals: 'ipsum'</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nAnd for malformed elements, we expect the following results:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testElementMalformedExtraClose\n\tsuper testElementMalformedExtraClose.\n\t\n\tself assert: result name equals: 'foo'.\n\tself assert: result secondChild text equals: '&lt;/fii&gt;'\n\nWebParserTest&gt;&gt;testElementMalformedWrongClose\n\tsuper testElementMalformedWrongClose.\n\t\n\tself assert: result name equals: 'foo'.\n\tself assert: result firstChild text equals: '&lt;bar&gt;meh&lt;/baz&gt;'\n\nWebParserTest&gt;&gt;testElementMalformedUnclosed\n\tsuper testElementMalformedUnclosed.\n\t\n\tself assert: result name equals: 'head'.\n\tself assert: result firstChild text trim equals: '&lt;meta content=&quot;mess&quot;&gt;'</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nAnd of course, we expect javascript code to be extracted as follows:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testJavascript\n\tsuper testJavascript.\n\t\n\tself assert: result code equals: 'alert(&quot;hi there!&quot;)'\n\nWebParserTest&gt;&gt;testJavascriptWithString\n\tsuper testJavascriptWithString.\n\t\n\tself assert: result code equals: 'alert(''&lt;/script&gt;'')'</code></pre><figcaption></figcaption></figure>\n\n</section><section>\n<h2>2. AST Nodes</h2>\n<p>\nIf we want to pass these test, the result of a parse should be a tree consisting of three different nodes: \n</p><ol><li>a javascript code; </li>\n<li>an html element; and</li>\n<li>a text.</li>\n</ol>\n\n<p>\nWe define these nodes as follows, starting with its abstract predecessor <code>WebElement</code>, which contains methods that ease our testing.\n</p>\n<figure><pre><code class=\"smalltalk\">Object subclass: #WebElement\n\tinstanceVariableNames: ''\n\tclassVariableNames: ''\n\tpoolDictionaries: ''\n\tcategory: 'PetitParser2-Tutorial'\n\nWebElement&gt;&gt;children\n\t^ #()\n\nWebElement&gt;&gt;firstChild\n\t&quot;Just for convenience&quot;\n\t^ self children first\n\nWebElement&gt;&gt;secondChild\n\t&quot;Just for convenience&quot;\n\t^ self children second\n\nWebElement&gt;&gt;gtTreeViewIn: composite\n\t&lt;gtInspectorPresentationOrder: 40&gt;\n\n\tcomposite tree\n\t\ttitle: 'Tree';\n\t\tchildren: [:n | n children ];\n\t\tformat: [:n| n displayText printStringLimitedTo: 50 ];\n\t\tshouldExpandToLevel: 6</code></pre><figcaption></figcaption></figure>\n\n<p>\n<code>JavascriptElement</code> follows:\n</p>\n<figure><pre><code class=\"smalltalk\">WebElement subclass: #JavascriptElement\n\tinstanceVariableNames: 'code'\n\tclassVariableNames: ''\n\tpoolDictionaries: ''\n\tcategory: 'PetitParser2-Tutorial'\n\nJavascriptElement&gt;&gt;code\n\t^ code\n\nJavascriptElement&gt;&gt;code: anObject\n\tcode := anObject\n\nJavascriptElement&gt;&gt;displayText\n\t^ self code\n\nJavascriptElement&gt;&gt;gtText: composite\n\t&lt;gtInspectorPresentationOrder: 40&gt;\n\t\n\tcomposite text\n\t\ttitle: 'Text';\n\t\tdisplay: [ :context | code ]</code></pre><figcaption></figcaption></figure>\n\n<p>\nAs well as <code>HtmlElement</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">WebElement subclass: #HtmlElement\n\tinstanceVariableNames: 'name children'\n\tclassVariableNames: ''\n\tpoolDictionaries: ''\n\tcategory: 'PetitParser2-Tutorial'\n\nHtmlElement&gt;&gt;children\n\t^ children\n\nHtmlElement&gt;&gt;name\n\t^ name\n\nHtmlElement&gt;&gt;name: newName\n\tname := newName\n\nHtmlElement&gt;&gt;displayText\n\t^ self name</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nLast but not least <code>UnknownText</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">WebElement subclass: #UnknownText\n\tinstanceVariableNames: 'text'\n\tclassVariableNames: ''\n\tpoolDictionaries: ''\n\tcategory: 'PetitParser2-Tutorial'\n\nUnknownText&gt;&gt;text\n\t^ text\n\nUnknownText&gt;&gt;text: anObject\n\ttext := anObject\n\nUnknownText&gt;&gt;gtText: composite\n\t&lt;gtInspectorPresentationOrder: 40&gt;\n\t\n\tcomposite text\n\t\ttitle: 'Text';\n\t\tdisplay: [ :context | text ]</code></pre><figcaption></figcaption></figure>\n\n\n\n</section><section>\n<h2>3. From Grammar to Parser</h2>\n\n<p>\nNow we override the rules of <code>WebGrammar</code> in <code>WebParser</code> so that the <code>javascript</code> rule returns <code>JavascriptElement</code>, the <code>element</code> rule returns <code>HtmlElement</code> and the <code>text</code> rule returns <code>UnknownText</code>:\n</p>\n\n<figure><pre><code class=\"smalltalk\">WebParser&gt;&gt;javascript\n\t^ super javascript\n\t\n\tmap: [ :_code | \n\t\t(JavascriptElement new)\n\t\t\tcode: _code;\n\t\t\tyourself\n\t]\n\nWebParser&gt;&gt;element\n\t^ super element \n\t\n\tmap: [ :_open :_content :_close | \n\t \t(HtmlElement new)\n\t\t\tname: _open;\n\t\t\tchildren: _content;\n\t\t\tyourself\n\t]\n\nWebParser&gt;&gt;text\n\t^ super text flatten\n\t\n\tmap: [ :_value | \n\t\tUnknownText new\n\t\t\ttext: _value;\n\t\t\tyourself\t\n\t]</code></pre><figcaption></figcaption></figure>\n\n<p>\nAnd finally, for convenience, we trim whitespaces around html elements:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParser&gt;&gt;elClose\n\t^ super elClose trim\n\nWebParser&gt;&gt;elOpen\n\t^ super elOpen trimRight</code></pre><figcaption></figcaption></figure>\n\n<p class=\"todo\">explain there is <code>trimRight</code> so that the caching is more efficient</p>\n<p>\nBy this time all the tests should pass:\n</p>\n<figure><pre><code class=\"smalltalk\">8 run, 8 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes</code></pre><figcaption></figcaption></figure>\n\n</section><section>\n<h2>4. Structured Document</h2>\n\n<p>\nNow the whole HTML document.\nThe pieces should be there, we need to connect them.\nOf course, we write tests first:\n</p>\n\n<figure><pre><code class=\"smalltalk\">WebGrammarTest&gt;&gt;testStructuredDocumentSimple\n\t| input |\n\tinput := '&lt;html&gt;\n\t\t&lt;body&gt;\n\t\t\t&lt;script&gt;alert(&quot;hello world&quot;)&lt;/script&gt;\n\t\t&lt;/body&gt;\n\t&lt;/html&gt;'.\n\t\n\tself parse: input rule: #structuredDocument\n\nWebGrammarTest&gt;&gt;testStructuredDocumentWithDoctype\n\t| input |\n\tinput := '\n&lt;!DOCTYPE html&gt;\n&lt;!-- comment --&gt;\n&lt;html&gt;\n\t&lt;body&gt;\n\t\t&lt;script&gt;alert(&quot;hello world&quot;)&lt;/script&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;'.\n\t\n\tself parse: input rule: #structuredDocument\n\nWebGrammarTest&gt;&gt;testStructuredDocument\n\t| input |\n\tinput := PP2Sources current htmlSample.\n\t\n\tself parse: input rule: #structuredDocument</code></pre><figcaption></figcaption></figure>\n\n<p>\nIn the previous chapters, we defined document (represented by the <code>document</code> rule) in <code>WebGrammar</code> as a repetition of javascript seas. \nNow we define a structured document, i.e. a document with an html structure. \nThe root of an html file is an element that can be surrounded by some other information (e.g. doctype or comments), therefore we define it as sea:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;structuredDocument\n\t^ element sea</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nIn order to verify the structure we extract from a document, we write the tests for parser:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testStructuredDocumentSimple\n\t| html body javascript |\n\tsuper testStructuredDocumentSimple.\n\t\n\tself assert: result name equals: 'DOCUMENT'.\n\n\n\thtml := result secondChild.\n\tself assert: html name equals: 'html'.\n\n\tbody := html firstChild.\n\tself assert: body name equals: 'body'.\n\t\n\tjavascript := body firstChild.\n\tself assert: javascript isKindOf: JavascriptElement.\n\tself assert: javascript code equals: 'alert(&quot;hello world&quot;)'.\n\nWebParserTest&gt;&gt;testStructuredDocumentWithDoctype\n\t| html body javascript |\n\tsuper testStructuredDocumentWithDoctype.\n\t\n\tself assert: result name equals: 'DOCUMENT'.\n\n\n\thtml := result secondChild.\n\tself assert: html name equals: 'html'.\n\n\tbody := html firstChild.\n\tself assert: body name equals: 'body'.\n\t\n\tjavascript := body firstChild.\n\tself assert: javascript isKindOf: JavascriptElement.\n\tself assert: javascript code equals: 'alert(&quot;hello world&quot;)'.\n\n\nWebParserTest&gt;&gt;testStructuredDocument\n\t| html |\n\tsuper testStructuredDocument.\n\t\n\tself assert: result name equals: 'DOCUMENT'.\n\n\n\thtml := result secondChild.\n\tself assert: html name equals: 'html'.\n\n\n\tself assert: html firstChild name equals: 'head'.\t\n\tself assert: html secondChild name equals: 'body'.</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nIn order to pass these tests, we create a root element from the structured document:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParser&gt;&gt;structuredDocument\n\t^ super structuredDocument\n\t\n\tmap: [ :_bw :_document :_aw |\n\t\t| beforeWater afterWater |\n\t\tbeforeWater := UnknownText new\n\t\t\ttext: _bw;\n\t\t\tyourself.\n\t\t\t\n\t\tafterWater := UnknownText new\n\t\t\ttext: _aw;\n\t\t\tyourself.\n\t\t\t\n\t\tHtmlElement new\n\t\t\tname: 'DOCUMENT';\n\t\t\tchildren: (Array with: beforeWater \n\t\t\t\t\t with: _document \n\t\t\t\t\t with: afterWater);\n\t\t\tyourself\n\t\n\t]</code></pre><figcaption></figcaption></figure>\n\n<p>\nBy this time all the tests should pass:\n</p><figure><pre><code class=\"smalltalk\">11 run, 11 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes</code></pre><figcaption></figcaption></figure>\n\n</section><section>\n<h2>5. Comments</h2>\n\n<p>\nIn this section we focus a bit more how to handle comments. They may contain scripts or other elements and they may confuse the parser. \n</p>\n<p>\nActually we have been cheating a bit and there is an error in <code>WebParser</code>, which extracts one element that is not in the HTML. Inspect the following and switch to the tree view:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParser new parse: input.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThere is a <em>&lt;p&gt;</em> element in the <em>&lt;body&gt;</em>. \nBut <em>&lt;p&gt;</em> is a part of comment, it should not be included in the document structure. \nWe fix the <code>testStructuredDocument</code> to cover this:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testStructuredDocument\n\t| html body |\n\tsuper testStructuredDocument.\n\t\n\tself assert: result name equals: 'DOCUMENT'.\n\n\thtml := result secondChild.\n\tself assert: html name equals: 'html'.\n\n\tself assert: html firstChild name equals: 'head'.\t\n\tself assert: html secondChild name equals: 'body'.\n\t\n\tbody := html secondChild.\n\tself assert: body children size equals: 4.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe problem is tha same as in the case of prematurely ended javascript.\n<code>WebGrammar</code> has no notion of a comment and handles a content of comment as an ordinary html code. \nTherefore we define what is an html comment:\n</p>\n\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;comment\n\t^ '&lt;!--' asPParser, #any asPParser starLazy, '--&gt;' asPParser</code></pre><figcaption></figcaption></figure>\n\n<p>\nAnd now we can redefine <code>text</code> so that it knows what is a comment:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;text\n\t^ (comment / #any asPParser) starLazy</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nWe already mentioned in the previous text that <code>starLazy</code> utilizes bounded seas and the above code is equivalent to:\n</p>\n<figure><pre><code class=\"smalltalk\">(#epsilon asPParser)\n  waterToken: (comment / #any asPParser);\n  yourself\t </code></pre><figcaption></figcaption></figure>\n\n\n<p>\nBecause now water knows what is a comment, it skips the complete comment including the <em>&lt;p&gt;</em> element inside.\n</p>\n\n<p>\nThis is it, we can parse all of it!\n</p>\n</section><section>\n<h2>6. Conclusion </h2>\n<p>\nIn this chapter we have applied the test-driven approach to define our AST nodes.\nWe defined <code>WebParser</code>, wchid extends the <code>WebGrammar</code> and builds the AST nodes.\nLast but not least, we had a look how to avoid false positives caused by comments.\n</p>\n\n\n<section>\n<h3>Complete Sources</h3>\n<p>\nYou can download the sources here:\n</p><ul>\n<li><a href=\"../WebGrammar.st\"><code>WebGrammar</code></a> </li>\n<li><a href=\"../WebGrammarTest.st\"><code>WebGrammarTest</code></a></li>\n<li><a href=\"../WebParser.st\"><code>WebParser</code></a> </li>\n<li><a href=\"../WebParserTest.st\"><code>WebParserTest</code></a></li>\n<li><a href=\"../WebElement.st\"><code>WebElement</code></a></li>\n<li><a href=\"../JavascriptElement.st\"><code>JavascriptElement</code></a></li>\n<li><a href=\"../HtmlElement.st\"><code>HtmlElement</code></a></li>\n<li><a href=\"../UnknownText.st\"><code>UnknownText</code></a></li>\n</ul>\n\n<p>\nThe source for this tutorial is also part of the PetitParser2 package.\n</p>\n<a id=\"toc\"></a><section>\n<h1>Table of Contents</h1>\n<p>\nThis text is part of the <a href=\"Chapters/../../book.html\">Parsing With PetitParser2</a> series.\n</p>\n<p>\nPart I, Basics:\n</p><ul>\n<li><a href=\"Chapters/../chapter1.html\">Extracting Javascript</a></li>\n<li><a href=\"Chapters/../chapter2.html\">From a Script to a Parser</a></li>\n<li><a href=\"Chapters/../chapter3.html\">Extracting the Structure</a></li>\n<li><a href=\"Chapters/../AST.html\">Abstract Syntax Tree</a></li>\n<li><a href=\"Chapters/../optimizations.html\">Optimizations</a></li>\n<li><a href=\"Chapters/../memoization.html\">Memoization</a></li>\n</ul>\n\n<p>\nPart II, Advanced Topics:\n</p><ul>\n<li><a href=\"Chapters/../starLazy.html\">The <code>starLazy</code> Operator</a></li>\n<li><a href=\"Chapters/../matchingTags.html\">Matching Tags</a></li>\n<li><a href=\"Chapters/../smalltalkOptimization.html\">Specializations in Detail</a></li>\n<li><a href=\"Chapters/../caches.html\">Caches in Detail</a></li>\n</ul>\n\n<p>\nGo to <a href=\"#top\">top</a>.\n</p></section></section></section></section>","title":"Parsing with PetitParser2","Author":"Jan Kurs"}