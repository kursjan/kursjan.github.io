{"content":"<p>\nThis text is part of the PetitParser2 series:\n</p><ul>\n<li><a href=\"Chapters/../chapter1.html\">Extracting Javascript</a></li>\n<li><a href=\"Chapters/../chapter2.html\">From Script to Parser</a></li>\n<li><a href=\"Chapters/../chapter3.html\">Extracting the Structure</a></li>\n<li><a href=\"Chapters/../AST.html\">Abstract Syntax Tree</a></li>\n<li><a href=\"Chapters/../chapter4.html\">Optimizations</a></li>\n<li><a href=\"Chapters/../chapter5.html\">Memoization</a></li>\n</ul>\n\n<p>\nAdditional Chapters:\n</p><ul>\n<li><a href=\"Chapters/../matching Tags.html\">Matching Tags</a></li>\n</ul>\n\n<section>\n<h2>1. Create an Abstract Syntax Tree</h2>\n\n<p>\nIn the previous chapter we tested that our grammar parses the nested elements,\nbut we have wery bad idea how does the extracted structure looks like.\nThe output of a parser is typically very detailed and not well readable concrete syntax tree, which is (in the case of PetitParser) array of arrays of arrays with characters and strings as terminals.\n</p>\n<p>\nIt is the time to return a more convenient representation of the input: <em>an abstract syntax tree</em>. \nAbstract syntax tree, contrary to the very low-level and detailed array of arrays  (so called concrete syntax tree), contains information closer to the target domain. \nIn our case the domain should be some kind of a javascript and html representation.\n</p>\n\n<p>\nIt is considered to be a good practice in PetitParser to split grammar, which returns concrete syntax tree, from parser, which returns abstract syntax tree. \nWe do this by subclassing <code>WebGrammar</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar subclass: #WebParser\n\tinstanceVariableNames: ''\n\tclassVariableNames: ''\n\tpoolDictionaries: ''\n\tcategory: 'PetitParser2-Tutorial'</code></pre><figcaption></figcaption></figure>\n\n<p>\nParsing is great use case for test driven development. \nIf you made it so far, you probably mean it with parsing.\nSo let us abandon on a totorial-friendly mode and do the development the recommended way:\n<em>start with tests</em>. \n</p>\n<p>\nTests give us a clear idea what kind of interface do we expect from our abstract syntax tree:\n</p>\n\n<p>\n[[[\nWebGrammarTest subclass: #WebParserTest\n\tuses: TPP2TypeAssertions\n\tinstanceVariableNames: <em>\n\tclassVariableNames: </em>\n\tpoolDictionaries: ''\n\tcategory: 'PetitParser2-Tutorial'\nWebParserTest&gt;&gt;parserClass\n\t^ WebParser\n</p>\n<pre>KeyNotFound: key #testElement not found in MethodDictionary</pre>\n\n<p>\nAnd for malformed elements, we expect the following results:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testElementMalformedExtraClose\n\tsuper testElementMalformedExtraClose.\n\t\n\tself assert: result name equals: 'foo'.\n\tself assert: result secondChild text equals: '&lt;/fii&gt;'\n\nWebParserTest&gt;&gt;testElementMalformedWrongClose\n\tsuper testElementMalformedWrongClose.\n\t\n\tself assert: result name equals: 'foo'.\n\tself assert: result firstChild text equals: '&lt;bar&gt;meh&lt;/baz&gt;'\n\nWebParserTest&gt;&gt;testElementMalformedUnclosed\n\tsuper testElementMalformedUnclosed.\n\t\n\tself assert: result name equals: 'head'.\n\tself assert: result firstChild text trim equals: '&lt;meta content=&quot;mess&quot;&gt;'</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nAnd of course, we expect javascript code to be extracted as follows:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testJavascript\n\tsuper testJavascript.\n\t\n\tself assert: result code equals: 'alert(1+2)'\n\nWebParserTest&gt;&gt;testJavascriptWithString\n\tsuper testJavascriptWithString.\n\t\n\tself assert: result code equals: 'alert(''&lt;/script&gt;'')'</code></pre><figcaption></figcaption></figure>\n\n\n\n<p>\nIf we want to pass these test, the result of a parse should be a tree consisting of three different nodes: \n</p><ol><li>an html element </li>\n<li>a javascript code and </li>\n<li>a text</li>\n</ol>\n<p>\nWe define these nodes as follows, starting with its abstract predecessor <code>WebElement</code>:\n</p>\n\n<figure><pre><code class=\"smalltalk\">Object subclass: #WebElement\n\tinstanceVariableNames: ''\n\tclassVariableNames: ''\n\tpackage: 'PetitParser2-SeasTutorial'\n\nWebElement&gt;&gt;children\n\t^ #()\n\nWebElement&gt;&gt;firstChild\n\t&quot;Just for convenience&quot;\n\t^ self children first\n\nWebElement&gt;&gt;secondChild\n\t&quot;Just for convenience&quot;\n\t^ self children second\n\nWebElement&gt;&gt;gtTreeViewIn: composite\n\t&lt;gtInspectorPresentationOrder: 40&gt;\n\n\tcomposite tree\n\t\ttitle: 'Tree';\n\t\tchildren: [:n | n children ];\n\t\tformat: [:n| n displayText printStringLimitedTo: 50 ];\n\t\tshouldExpandToLevel: 6</code></pre><figcaption></figcaption></figure>\n\n\n<p>\n<code>HtmlElement</code> follows:\n</p>\n<figure><pre><code class=\"smalltalk\">WebElement subclass: #HtmlElement\n\tinstanceVariableNames: 'name children'\n\tclassVariableNames: ''\n\tpackage: 'PetitParser2-SeasTutorial'\n\nHtmlElement&gt;&gt;children\n\t^ children\n\nchildren: anObject\n\tchildren := anObject\n\nname\n\t^ name\n\nname: newName\n\tname := newName\n\t\ndisplayText\n\t^ self name</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nAs well as <code>UnknownText</code>:\n</p><figure><pre><code class=\"smalltalk\">WebElement subclass: #UnknownText\n\tinstanceVariableNames: 'text'\n\tclassVariableNames: ''\n\tpackage: 'PetitParser2-SeasTutorial'\n\n\nUnknownText&gt;&gt;text\n\t^ text\n\nUnknownText&gt;&gt;text: anObject\n\ttext := anObject\n\nUnknownText&gt;&gt;displayText\n\t^ self text trim\n\nUnknownText&gt;&gt;gtText: composite\n\t&lt;gtInspectorPresentationOrder: 40&gt;\n\t\n\tcomposite text\n\t\ttitle: 'Text';\n\t\tdisplay: [ :context | text ]</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nLast but not least there is <code>JavascriptElement</code>:\n</p><figure><pre><code class=\"smalltalk\">WebElement subclass: #JavascriptElement\n\tinstanceVariableNames: 'code'\n\tclassVariableNames: ''\n\tpackage: 'PetitParser2-SeasTutorial'\n\nJavascriptElement&gt;&gt;code\n\t^ code\n\nJavascriptElement&gt;&gt;code: anObject\n\tcode := anObject\n\nJavascriptElement&gt;&gt;displayText\n\t^ self code\n\nJavascriptElement&gt;&gt;gtText: composite\n\t&lt;gtInspectorPresentationOrder: 40&gt;\n\t\n\tcomposite text\n\t\ttitle: 'Text';\n\t\tdisplay: [ :context | code ]</code></pre><figcaption></figcaption></figure>\n\n<p>\nNow we use <code>WebParser</code> to update the <code>javascript</code> rule, to return <code>JavascriptElement</code>, the <code>element</code> rule to return <code>HtmlElement</code> and the <code>text</code> rule to return <code>UnknownText</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParser&gt;&gt;javascript\n\t^ super javascript \n\t\n\tmap: [ :_open :_content :_close | \n\t \t(JavascriptElement new)\n\t\t\tcode: _content;\n\t\t\tyourself\n\t]\n\nWebParser&gt;&gt;element\n\t^ super element \n\t\n\tmap: [ :_open :_content :_close | \n\t \t(HtmlElement new)\n\t\t\tname: _open;\n\t\t\tchildren: _content;\n\t\t\tyourself\n\t]\n\nWebParser&gt;&gt;text\n\t^ super text \n\t\n\tmap: [ :_value | \n\t\tUnknownText new\n\t\t\ttext: _value;\n\t\t\tyourself\t\n\t]</code></pre><figcaption></figcaption></figure>\n\n<p>\nAnd finally, for convenience, we trim whitespaces around html elements:\n</p>\n\n<figure><pre><code class=\"smalltalk\">WebParser&gt;&gt;elClose\n\t^ super elClose trimLeft\n\nWebParser&gt;&gt;elOpen\n\t^ super elOpen trimRight</code></pre><figcaption></figcaption></figure>\n<p class=\"todo\">there is no <code>trimLeft</code> in the source code, fix it...</p>\n</section><section>\n<h2>2. Structured Document</h2>\n\n<p>\nWe defined document in <code>WebGrammar</code> as a repetition of javascript seas. \nNow we define structured document, i.e. a document with an html structure. \nThe root of an html file is an element that can be surrounded by some other information (e.g. doctype or comments), therefore we define it as sea:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;structuredDocument\n\t^ element sea\n\nWebGrammar&gt;&gt;start\n\t^ structuredDocument</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nAnd we should write tests for this:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammarTest&gt;&gt;testStructuredDocument\n\t| input |\n\tinput := '&lt;html&gt;\n\t\t&lt;body&gt;\n\t\t\t&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;hello world&quot;)&lt;/script&gt;\n\t\t&lt;/body&gt;\n\t&lt;/html&gt;'.\n\t\n\tself parse: input rule: #structuredDocument\n\nWebGrammarTest&gt;&gt;testStructuredDocumentWithDoctype\n\t| input |\n\tinput := '\n&lt;!DOCTYPE html&gt;\n&lt;!-- comment --&gt;\n&lt;html&gt;\n\t&lt;meta content=&quot;origin&quot; name=&quot;referrer&quot;&gt;\n\n\n\t&lt;body&gt;\n\t\t&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;hello world&quot;)&lt;/script&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;'.\n\t\n\tself parse: input rule: #structuredDocument</code></pre><figcaption></figcaption></figure>\n\n\n\n<p>\nWe create a root element from the structured document:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParser&gt;&gt;structuredDocument\n\t^ super structuredDocument\n\t\n\tmap: [ :_bw :_document :_aw |\n\t\t| beforeWater afterWater |\n\t\tbeforeWater := UnknownText new\n\t\t\ttext: _bw;\n\t\t\tyourself.\n\t\t\t\n\t\tafterWater := UnknownText new\n\t\t\ttext: _aw;\n\t\t\tyourself.\n\t\t\t\n\t\tHtmlElement new\n\t\t\tname: 'DOCUMENT';\n\t\t\tchildren: (Array with: beforeWater \n\t\t\t\t\t with: _document \n\t\t\t\t\t with: afterWater);\n\t\t\tyourself\n\t\n\t]</code></pre><figcaption></figcaption></figure>\n\n<p>\nAnd we cover the rule with a test:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testStructuredDocument\n\t| html |\n\tsuper testStructuredDocument.\n\t\n\tself assert: result name equals: 'DOCUMENT'.\n\n\n\thtml := result secondChild.\n\tself assert: html name equals: 'html'.\n\n\n\tself assert: html firstChild name equals: 'head'.\t\n\tself assert: html secondChild name equals: 'body'.</code></pre><figcaption></figcaption></figure>\n\n</section><section>\n<h2>3. Comments</h2>\n\n<p>\nIn this section we focus a bit more how to handle comments. They may contain scripts or other elements and they may confuse the parser. \nActually this is happening in <code>WebParser</code>, which extracts one element that is not in the HTML. Inspect the following and switch to the tree view:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParser new parse: input.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThere is a <em>&lt;p&gt;</em> element in the <em>&lt;body&gt;</em>. \nBut <em>&lt;p&gt;</em> is a part of comment, it should not be included in the document structure. \nWe write a test to cover this:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testStructuredDocument\n\t| html |\n\tsuper testStructuredDocument.\n\t\n\tself assert: result name equals: 'DOCUMENT'.\n\n\thtml := result secondChild.\n\tself assert: html name equals: 'html'.\n\n\tself assert: html firstChild name equals: 'head'.\t\n\tself assert: html secondChild name equals: 'body'.\n\n\tbody := html secondChild.\n\tself assert: body children size equals: 4.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe problem is, as in the case of prematurely ended javascript, that our parser has no notion of a comment and handles a content of comment as an ordinary html code. \nTherefore we define what is an html comment:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;comment\n\t^ '&lt;!--' asPParser, #any asPParser starLazy, '--&gt;' asPParser</code></pre><figcaption></figcaption></figure>\n\n<p>\nAnd now we can redefine <code>text</code> so that it knows what is a comment:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;text\n\t^ (comment / #any asPParser) starLazy</code></pre><figcaption></figcaption></figure>\n\n<p>\nWe already mentioned in the previous text that <code>starLazy</code> utilizes bounded seas and the above code is equivalent to:\n</p>\n<figure><pre><code class=\"smalltalk\">(#epsilon asPParser)\n  waterToken: (comment / #any asPParser);\n  yourself\t </code></pre><figcaption></figcaption></figure>\n\n\n<p>\nBecause now water knows what is a comment, it skips the complete comment including the <em>&lt;p&gt;</em> element inside.\n</p>\n\n<p>\nThis is it. \nYour tests are passing right now.\n\n</p></section>","title":"PetitParser2 and Bounded Seas","Author":"Jan Kurs"}