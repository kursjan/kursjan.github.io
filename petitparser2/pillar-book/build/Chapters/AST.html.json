{"content":"<a id=\"top\"></a>\n<p>\nThis text is part of the <a href=\"Chapters/../../book.html\">Parsing With PetitParser2</a> series.\nThe <a href=\"#toc\">table of content</a> can be found at the end of the chapter.\n\n</p>\n<section>\n<h1>Create an Abstract Syntax Tree</h1>\n<p>\nIn the <a href=\"chapter3.html\">previous chapter</a> we tested that our grammar parses the nested elements,\nbut we have very limited knowledge about how does the extracted structure look like.\nSo let us improve improve the output from the parser and add some information.\n</p>\n<p>\nThe direct output of a parser is typically very detailed and not well-readable. \nIt is called concrete syntax tree (CST), which is (in the case of PetitParser) array of arrays of arrays of ... with characters and strings as terminals.\n</p>\n<p>\nIt is the time to return a more convenient representation of the input: <em>an abstract syntax tree</em>, in short AST. \nAbstract syntax tree, contrary to the very low-level and detailed concrete syntax tree, is conceptually closer to the target domain. \nIn our case the domain should be some kind of a tree with html elements and javascript.\n</p>\n\n<p>\nIt is considered to be a good practice in PetitParser to split grammar, which returns concrete syntax tree, from parser, which returns abstract syntax tree. \nWe do this by subclassing <code>WebGrammar</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar subclass: #WebParser\n\tinstanceVariableNames: ''\n\tclassVariableNames: ''\n\tpoolDictionaries: ''\n\tcategory: 'PetitParser2-Tutorial'</code></pre><figcaption></figcaption></figure>\n\n<section>\n<h2>1. Testing First</h2>\n\n<p>\nParsing is great use case for test driven development. \nSo let us start with tests first. \nTests give us a clear idea what kind of interface we expect from abstract syntax tree:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammarTest subclass: #WebParserTest\n\tuses: TPP2TypeAssertions\n\tinstanceVariableNames: ''\n\tclassVariableNames: ''\n\tpoolDictionaries: ''\n\tcategory: 'PetitParser2-Tutorial'\n\nWebParserTest&gt;&gt;parserClass\n\t^ WebParser\n\nWebParserTest&gt;&gt;testElement\n\tsuper testElement.\n\t\n\tself assert: result name equals: 'p'.\n\tself assert: result firstChild text equals: 'lorem ipsum'\n\nWebParserTest&gt;&gt;testElementEmpty\n\tsuper testElementEmpty.\n\t\n\tself assert: result name equals: 'foo'.\n\nWebParserTest&gt;&gt;testElementNested\n\tsuper testElementNested.\n\t\n\tself assert: result name equals: 'p'.\n\tself assert: result firstChild text trim equals: 'lorem'.\n\tself assert: result secondChild name equals: 'i'.\n\tself assert: result secondChild firstChild text equals: 'ipsum'</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nAnd for malformed elements, we expect the following results:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testElementMalformedExtraClose\n\tsuper testElementMalformedExtraClose.\n\t\n\tself assert: result name equals: 'foo'.\n\tself assert: result secondChild text equals: '&lt;/fii&gt;'\n\nWebParserTest&gt;&gt;testElementMalformedWrongClose\n\tsuper testElementMalformedWrongClose.\n\t\n\tself assert: result name equals: 'foo'.\n\tself assert: result firstChild text equals: '&lt;bar&gt;meh&lt;/baz&gt;'\n\nWebParserTest&gt;&gt;testElementMalformedUnclosed\n\tsuper testElementMalformedUnclosed.\n\t\n\tself assert: result name equals: 'head'.\n\tself assert: result firstChild text trim equals: '&lt;meta content=&quot;mess&quot;&gt;'</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nAnd of course, we expect javascript code to be extracted as follows:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testJavascript\n\tsuper testJavascript.\n\t\n\tself assert: result code equals: 'alert(&quot;hi there!&quot;)'\n\nWebParserTest&gt;&gt;testJavascriptWithString\n\tsuper testJavascriptWithString.\n\t\n\tself assert: result code equals: 'alert(''&lt;/script&gt;'')'</code></pre><figcaption></figcaption></figure>\n\n</section><section>\n<h2>2. AST Nodes</h2>\n<p>\nIf we want to pass these test, the result of a parse should be a tree consisting of three different nodes: \n</p><ol><li>a javascript code; </li>\n<li>an html element; and</li>\n<li>a text.</li>\n</ol>\n\n<p>\nWe define these nodes as follows, starting with its abstract predecessor <code>WebElement</code>, which contains methods that ease our testing.\n</p>\n<figure><pre><code class=\"smalltalk\">Object subclass: #WebElement\n\tinstanceVariableNames: ''\n\tclassVariableNames: ''\n\tpoolDictionaries: ''\n\tcategory: 'PetitParser2-Tutorial'\n\nWebElement&gt;&gt;children\n\t^ #()\n\nWebElement&gt;&gt;firstChild\n\t&quot;Just for convenience&quot;\n\t^ self children first\n\nWebElement&gt;&gt;secondChild\n\t&quot;Just for convenience&quot;\n\t^ self children second\n\nWebElement&gt;&gt;gtTreeViewIn: composite\n\t&lt;gtInspectorPresentationOrder: 40&gt;\n\n\tcomposite tree\n\t\ttitle: 'Tree';\n\t\tchildren: [:n | n children ];\n\t\tformat: [:n| n displayText printStringLimitedTo: 50 ];\n\t\tshouldExpandToLevel: 6</code></pre><figcaption></figcaption></figure>\n\n<p>\n<code>JavascriptElement</code> follows:\n</p>\n<figure><pre><code class=\"smalltalk\">WebElement subclass: #JavascriptElement\n\tinstanceVariableNames: 'code'\n\tclassVariableNames: ''\n\tpoolDictionaries: ''\n\tcategory: 'PetitParser2-Tutorial'\n\nJavascriptElement&gt;&gt;code\n\t^ code\n\nJavascriptElement&gt;&gt;code: anObject\n\tcode := anObject\n\nJavascriptElement&gt;&gt;displayText\n\t^ self code\n\nJavascriptElement&gt;&gt;gtText: composite\n\t&lt;gtInspectorPresentationOrder: 40&gt;\n\t\n\tcomposite text\n\t\ttitle: 'Text';\n\t\tdisplay: [ :context | code ]</code></pre><figcaption></figcaption></figure>\n\n<p>\nAs well as <code>HtmlElement</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">WebElement subclass: #HtmlElement\n\tinstanceVariableNames: 'name children'\n\tclassVariableNames: ''\n\tpoolDictionaries: ''\n\tcategory: 'PetitParser2-Tutorial'\n\nHtmlElement&gt;&gt;children\n\t^ children\n\nHtmlElement&gt;&gt;name\n\t^ name\n\nHtmlElement&gt;&gt;name: newName\n\tname := newName\n\nHtmlElement&gt;&gt;displayText\n\t^ self name</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nLast but not least <code>UnknownText</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">WebElement subclass: #UnknownText\n\tinstanceVariableNames: 'text'\n\tclassVariableNames: ''\n\tpoolDictionaries: ''\n\tcategory: 'PetitParser2-Tutorial'\n\nUnknownText&gt;&gt;text\n\t^ text\n\nUnknownText&gt;&gt;text: anObject\n\ttext := anObject\n\nUnknownText&gt;&gt;gtText: composite\n\t&lt;gtInspectorPresentationOrder: 40&gt;\n\t\n\tcomposite text\n\t\ttitle: 'Text';\n\t\tdisplay: [ :context | text ]</code></pre><figcaption></figcaption></figure>\n\n\n\n</section><section>\n<h2>3. From a Grammar to a Parser</h2>\n\n<p>\nNow we override the rules of <code>WebGrammar</code> in <code>WebParser</code> so that the <code>javascript</code> rule returns <code>JavascriptElement</code>, the <code>element</code> rule returns <code>HtmlElement</code> and the <code>text</code> rule returns <code>UnknownText</code>:\n</p>\n\n<figure><pre><code class=\"smalltalk\">WebParser&gt;&gt;javascript\n\t^ super javascript\n\t\n\tmap: [ :_code | \n\t\t(JavascriptElement new)\n\t\t\tcode: _code;\n\t\t\tyourself\n\t]\n\nWebParser&gt;&gt;element\n\t^ super element \n\t\n\tmap: [ :_open :_content :_close | \n\t \t(HtmlElement new)\n\t\t\tname: _open;\n\t\t\tchildren: _content;\n\t\t\tyourself\n\t]\n\nWebParser&gt;&gt;text\n\t^ super text flatten\n\t\n\tmap: [ :_value | \n\t\tUnknownText new\n\t\t\ttext: _value;\n\t\t\tyourself\t\n\t]</code></pre><figcaption></figcaption></figure>\n\n<p>\nAnd finally, for convenience, we trim whitespaces around html elements:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParser&gt;&gt;elClose\n\t^ super elClose trim\n\nWebParser&gt;&gt;elOpen\n\t^ super elOpen trimRight</code></pre><figcaption></figcaption></figure>\n\n<p class=\"note\">There is <code>trimRight</code> in <code>elOpen</code>, which means that only the whitespace on the right is trimmed. This makes caching of PetitParser slightly more efficient, because element always starts at the first non-whitespace character. If there is a trimming from left and right (using the <code>trim</code>), it might start at any preceding whitespace or the first non-whitespace character and this would lead into lower cache-hit ratio.</p>\n<p>\nBy this time all the tests should pass:\n</p>\n<figure><pre><code class=\"smalltalk\">8 run, 8 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes</code></pre><figcaption></figcaption></figure>\n\n</section><section>\n<h2>4. Structured Document</h2>\n\n<p>\nNow let us construct the whole HTML document.\nThe pieces are already there, we just need to connect them.\n</p>\n<p>\nIn the previous chapters, we defined document (represented by the <code>document</code> rule) in <code>WebGrammar</code> as a repetition of javascript seas. \nNow we define a structured document (<code>structuredDocument</code>), i.e. a document with an html structure. \nOf course, we write tests first and we start with <code>WebGrammarTest</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammarTest&gt;&gt;testStructuredDocumentSimple\n\t| input |\n\tinput := '&lt;html&gt;\n\t\t&lt;body&gt;\n\t\t\t&lt;script&gt;alert(&quot;hello world&quot;)&lt;/script&gt;\n\t\t&lt;/body&gt;\n\t&lt;/html&gt;'.\n\t\n\tself parse: input rule: #structuredDocument\n\nWebGrammarTest&gt;&gt;testStructuredDocumentWithDoctype\n\t| input |\n\tinput := '\n&lt;!DOCTYPE html&gt;\n&lt;!-- comment --&gt;\n&lt;html&gt;\n\t&lt;body&gt;\n\t\t&lt;script&gt;alert(&quot;hello world&quot;)&lt;/script&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;'.\n\t\n\tself parse: input rule: #structuredDocument\n\nWebGrammarTest&gt;&gt;testStructuredDocument\n\t| input |\n\tinput := PP2Sources current htmlSample.\n\t\n\tself parse: input rule: #structuredDocument</code></pre><figcaption></figcaption></figure>\n\n<p>\nFrom the tests we see that the root of an html file is an element that can be surrounded by some other information (e.g. doctype or comments), therefore we define structured document as an element surrounded by a sea:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;structuredDocument\n\t^ element sea</code></pre><figcaption></figcaption></figure>\n\n<p>\nFurthermore, we verify that we extract the correct structure of the document. \nThis can be done in the <code>WebParserTest</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testStructuredDocumentSimple\n\t| html body javascript |\n\tsuper testStructuredDocumentSimple.\n\t\n\tself assert: result name equals: 'DOCUMENT'.\n\n\n\thtml := result secondChild.\n\tself assert: html name equals: 'html'.\n\n\tbody := html firstChild.\n\tself assert: body name equals: 'body'.\n\t\n\tjavascript := body firstChild.\n\tself assert: javascript isKindOf: JavascriptElement.\n\tself assert: javascript code equals: 'alert(&quot;hello world&quot;)'.\n\nWebParserTest&gt;&gt;testStructuredDocumentWithDoctype\n\t| html body javascript |\n\tsuper testStructuredDocumentWithDoctype.\n\t\n\tself assert: result name equals: 'DOCUMENT'.\n\n\n\thtml := result secondChild.\n\tself assert: html name equals: 'html'.\n\n\tbody := html firstChild.\n\tself assert: body name equals: 'body'.\n\t\n\tjavascript := body firstChild.\n\tself assert: javascript isKindOf: JavascriptElement.\n\tself assert: javascript code equals: 'alert(&quot;hello world&quot;)'.\n\n\nWebParserTest&gt;&gt;testStructuredDocument\n\t| html body |\n\tsuper testStructuredDocument.\n\t\n\tself assert: result name equals: 'DOCUMENT'.\n\n\thtml := result secondChild.\n\tself assert: html name equals: 'html'.\n\n\tself assert: html firstChild name equals: 'head'.\t\n\tself assert: html secondChild name equals: 'body'.</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nIn order to pass these tests, we create a root element called <em>DOCUMENT</em> in <code>structuredDocument</code>.\nFurthermore we add to it the html element as well a its surroundings:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParser&gt;&gt;structuredDocument\n\t^ super structuredDocument\n\t\n\tmap: [ :_bw :_html :_aw |\n\t\t| beforeWater afterWater |\n\t\tbeforeWater := UnknownText new\n\t\t\ttext: _bw;\n\t\t\tyourself.\n\t\t\t\n\t\tafterWater := UnknownText new\n\t\t\ttext: _aw;\n\t\t\tyourself.\n\t\t\t\n\t\tHtmlElement new\n\t\t\tname: 'DOCUMENT';\n\t\t\tchildren: (Array \n\t\t\t\twith: beforeWater \n\t\t\t\twith: _html \n\t\t\t\twith: afterWater);\n\t\t\tyourself\n\t]</code></pre><figcaption></figcaption></figure>\n\n<p>\nBy this time all the tests should pass:\n</p><figure><pre><code class=\"smalltalk\">11 run, 11 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes</code></pre><figcaption></figcaption></figure>\n\n</section><section>\n<h2>5. Comments</h2>\n\n<p>\nIn this section we focus on HTML comments. \nComments can contain scripts or other elements that are not part of the html document (they are just comments that look the same). \nAnd they may confuse the parser. \n</p>\n<p>\nActually they do and they do so in our tests as well!\nThere is an error in <code>WebParser</code> that we have not found. \nIt extracts one extra HTML element, which is not part of the HTML document.\nInspect the following and switch to the tree view:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParser new parse: input.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThere is a <em>&lt;p&gt;</em> element in the <em>&lt;body&gt;</em>. \nBut <em>&lt;p&gt;</em> is a part of a comment, it should not be included in the document structure. \nFirst, we should fix the <code>testStructuredDocument</code> to cover this case:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testStructuredDocument\n\t| html body |\n\tsuper testStructuredDocument.\n\t\n\tself assert: result name equals: 'DOCUMENT'.\n\n\thtml := result secondChild.\n\tself assert: html name equals: 'html'.\n\n\tself assert: html firstChild name equals: 'head'.\t\n\tself assert: html secondChild name equals: 'body'.\n\t\n\tbody := html secondChild.\n\tself assert: body children size equals: 4.</code></pre><figcaption></figcaption></figure>\n\n<p>\nSo where does the problem come from?\nThe cause is the same as in the case of prematurely ended javascript.\n<code>WebGrammar</code> has no notion of a comment and handles a content of a comment as an ordinary html code. \nIn order to teach it what is an html comment, we have to define it:\n</p>\n\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;comment\n\t^ '&lt;!--' asPParser, #any asPParser starLazy, '--&gt;' asPParser</code></pre><figcaption></figcaption></figure>\n\n<p>\nAnd now we can redefine <code>text</code> so that it takes comments into an account:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;text\n\t^ (comment / #any asPParser) starLazy</code></pre><figcaption></figcaption></figure>\n\n<p>\nIf you are interested in the details of the <code>starLazy</code> operator, check out the <a href=\"starLazy.html\">The <code>starLazy</code> Operator</a> chapter. \n</p>\n<figure><pre><code class=\"smalltalk\">(#epsilon asPParser)\n  waterToken: (comment / #any asPParser);\n  yourself\t </code></pre><figcaption></figcaption></figure>\n\n\n<p>\nBecause now water knows what is a comment, it skips the complete comment including the <em>&lt;p&gt;</em> element inside.\n</p>\n\n<p>\nThis is it, we can parse all of it!\n</p>\n</section><section>\n<h2>6. Conclusion </h2>\n<p>\nIn this chapter we have applied the test-driven approach to define our AST nodes.\nWe defined <code>WebParser</code>, which extends the <code>WebGrammar</code> and builds the AST nodes.\nLast but not least, we had a look how to avoid false positives caused by comments.\n</p>\n\n\n<section>\n<h3>Complete Sources</h3>\n<p>\nYou can download the sources here:\n</p><ul>\n<li><a href=\"../WebGrammar.st\"><code>WebGrammar</code></a> </li>\n<li><a href=\"../WebGrammarTest.st\"><code>WebGrammarTest</code></a></li>\n<li><a href=\"../WebParser.st\"><code>WebParser</code></a> </li>\n<li><a href=\"../WebParserTest.st\"><code>WebParserTest</code></a></li>\n<li><a href=\"../WebElement.st\"><code>WebElement</code></a></li>\n<li><a href=\"../JavascriptElement.st\"><code>JavascriptElement</code></a></li>\n<li><a href=\"../HtmlElement.st\"><code>HtmlElement</code></a></li>\n<li><a href=\"../UnknownText.st\"><code>UnknownText</code></a></li>\n</ul>\n\n<p>\nThe sources of this tutorial is also part of the PetitParser2 package, so you just need to install PetitParser or use Moose as described in the <a href=\"../book.html\">Introduction</a>.\n</p>\n<a id=\"toc\"></a><section>\n<h1>Table of Contents</h1>\n<p>\nThis text is part of the <a href=\"Chapters/../../book.html\">Parsing With PetitParser2</a> series.\n</p>\n<p>\nPart I, Developer's Workflow:\n</p><ul>\n<li><a href=\"Chapters/../chapter1.html\">Extracting Javascript</a></li>\n<li><a href=\"Chapters/../chapter2.html\">From a Script to a Parser</a></li>\n<li><a href=\"Chapters/../chapter3.html\">Extracting the Structure</a></li>\n<li><a href=\"Chapters/../AST.html\">Abstract Syntax Tree</a></li>\n<li><a href=\"Chapters/../optimizations.html\">Optimizations</a></li>\n<li><a href=\"Chapters/../memoization.html\">Memoization</a></li>\n</ul>\n\n<p>\nPart II, Advanced Topics:\n</p><ul>\n<li><a href=\"Chapters/../starLazy.html\">The <code>starLazy</code> Operator</a></li>\n<li><a href=\"Chapters/../matchingTags.html\">Matching Tags</a></li>\n<li><a href=\"Chapters/../smalltalkOptimization.html\">Specializations in Detail</a></li>\n<li><a href=\"Chapters/../caches.html\">Caches in Detail</a></li>\n</ul>\n\n<p>\nGo to <a href=\"#top\">top</a>.\n\n</p></section></section></section></section>","title":"Parsing with PetitParser2","Author":"Jan Kurs"}