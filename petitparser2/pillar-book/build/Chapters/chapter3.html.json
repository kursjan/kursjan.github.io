{"content":"<p>\nThis text is part of the PetitParser2 series:\n</p><ul>\n<li><a href=\"Chapters/../chapter1.html\">Extracting Javascript</a></li>\n<li><a href=\"Chapters/../chapter2.html\">From Script to Parser</a></li>\n<li><a href=\"Chapters/../chapter3.html\">Extracting Structure</a></li>\n<li><a href=\"Chapters/../chapter4.html\">Optimizations</a></li>\n<li><a href=\"Chapters/../chapter5.html\">Memoization</a></li>\n</ul>\n\n<section>\n<h1>Extracting the Structure</h1>\n<a id=\"sec:structure\"></a>\n<p>\nIn the previous parts of this tutorial we analyzed the anatomy of bounded seas.\nWe described how they can be used to:\n</p><ol><li>extract islands --- parts of our interest while skipping the rest as a water (javascript seas in document), and </li>\n<li>implement a starLazy operator that skips an input until an interesting input appears (e.g. <code>(jsString / any) starLazy</code> in <code>jsContent</code>). </li>\n</ol>\n\n\n<p>\nIn this part we extend our parser and we extract the HTML structure. \nWe use bounded seas again to skip the content of html elements and recover from malformed or unclosed elements.\n</p>\n\n<section>\n<h2>I. Matching the Names</h2>\n\n\n<p>\nThe elements of HTML has an interesting property: the name of an opening tag has to match the name of a closing tag. \nEven though natural for human beings, this is, surprisingly, rather difficult task from the parsing theory point of view.\n</p>\n\n<p>\nOne of the standard solutions provided by parsing frameworks (including PetitParser) are parsing actions. \nWe define an action to assert that the name of an open tag corresponds to the name of a close tag:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;element\n\t^ elOpen, content, elClose\n\n\tmap: [:_open :_content :_close |\n\t(_open = _close) ifTrue: [\n\t\t_content\n\t] ifFalse: [ \n\t\tPP2Failure message: ‘open and close do not match’.\n\t]</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nUnfortunately, this solution has a problem with unclosed elements like these:\n</p>\n<figure><pre><code class=\"smalltalk\">&lt;b&gt;&lt;i&gt;bold and italics&lt;/b&gt;</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe first <code>elOpen</code> consumes <em>&lt;b&gt;</em>, \nthe second <code>elOpen</code> consumes \n<em>&lt;i&gt;</em>, \ncontent consumes <em>bold and italics</em> and \n<code>elClose</code> consumes <em>&lt;/b&gt;</em>. \nThe action checks if <em>i = b</em> and returns failure. \nThe failure will be the final result because such a code does not restore position to recover from the failure and actions do not offer a way to do so. \nOther options based on custom parsers or wrapping parsers will sooner or later run into a hard to debug issues with backtracking as well.\n</p>\n<p>\nThe PetitParser2 offers more formal way of such definitions. \nIt can store a result of a rule (e.g. <code>elOpen</code>) onto a stack using the push operator and assert that the result of a rule (e.g. <code>elClose</code>) matches the top of the stack using the match operator and finally pop the result using the pop operator. \nHere is the concrete example. \n</p>\n\n<p>\nFirst we define an element name as a repetition of letters and digits:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;elementName\n\t^ #word asPParser plus flatten</code></pre><figcaption></figcaption></figure>\n\n<p>\nThan we define element as a sequence of <code>elOpen</code>, <code>elContent</code> and <code>elClose</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;element\n\t^ (elOpen, elContent, elClose)</code></pre><figcaption></figcaption></figure>\n\n<p>\nIn <code>elOpen</code>, we push the element name as well as we consume water in case an element contains arguments:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;elOpen\n\t^ $&lt; asPParser, elementName push, #any starLazy, $&gt; asPParser ==&gt; #second</code></pre><figcaption></figcaption></figure>\n\n<p>\nIn <code>elClose</code>, we first match the element name against the top of a stack and we pop the stack in case of success:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;elClose\n\t^ '&lt;/' asPParser, elementName match pop, $&gt; asPParser</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nNow we need to define what is a content of an element. \nIt is a list of the following components in the given order: \n</p><ol><li>a javascript code, </li>\n<li>another element or </li>\n<li>an unknown text. </li>\n</ol>\n<p>\nWe add javascript to the first position because it is kind of an element and therefore must be ordered first to take precedence. \nThe same goes for an element, it is also <em>kind of</em> a text. \n</p>\n\n<p>\nFurthermore, we mark text as <code>nonEpsilon</code>, which allows only for non-empty parses. \nRemember <code>#water asPParser</code> can consume anything, even the empty string. \nThe star repetition would end up in an infinite loop recognizing an epsilon in each of its iteration, never failing, never stopping.\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;text\n\t^ #any starLazy\n\nWebGrammar&gt;&gt;elContent\n\t^ (javascript / element / text nonEpsilon) star</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nWe have defined a lots of code. Let us try, if it works. \nWe start with <code>text</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammarTest&gt;&gt;testText\n\tself parse: 'foobar' rule: #text</code></pre><figcaption></figcaption></figure>\n\n<p>\nAnd <code>element</code> follows:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammarTest&gt;&gt;testElementEmpty\n\tself parse: '&lt;foo&gt;&lt;/foo&gt;' rule: #element\n\nWebGrammarTest&gt;&gt;testElement\n\tself parse: '&lt;p&gt;lorem ipsum&lt;/p&gt;' rule: #element\n\nWebGrammarTest&gt;&gt;testElementNested\n\tself parse: '&lt;p&gt;lorem &lt;i&gt;ipsum&lt;/i&gt;&lt;/p&gt;' rule: #element</code></pre><figcaption></figcaption></figure>\n\n<p>\nWe should be able to parse malformed elements as well:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammarTest&gt;&gt;testElementMalformedWrongClose\n\tself parse: '&lt;foo&gt;&lt;bar&gt;meh&lt;/baz&gt;&lt;/foo&gt;' rule: #element.\n\nWebGrammarTest&gt;&gt;testElementMalformedExtraClose\n\tself parse: '&lt;foo&gt;&lt;bar&gt;meh&lt;/bar&gt;&lt;/fii&gt;&lt;/foo&gt;' rule: #element\n\nWebGrammarTest&gt;&gt;testElementMalformedUnclosed\n\tself parse: '&lt;head&gt;&lt;meta content=&quot;mess&quot;&gt;&lt;/head&gt;' rule: #element.</code></pre><figcaption></figcaption></figure>\n\n</section><section>\n<h2>II. Create an Abstract Syntax Tree</h2>\n\n<p>\nThat looks good. \nBut our tests are telling us only that element can parse the given input, it does not tell us how it parses the input. \nWe should assert that the proper element names and the right content is extracted. \n</p>\n\n<p>\nIt is the time to return a more convenient representation of the input: <em>an abstract syntax tree</em>. \nAbstract syntax tree, contrary to the very low-level and detailed array of arrays  (so called concrete syntax tree), contains information closer to the target domain. \nIn our case the domain should be some kind of a javascript and html representation.\n</p>\n\n<p>\nIt is considered to be a good practice in PetitParser to split grammar, which returns concrete syntax tree, from parser, which returns abstract syntax tree. \nWe do this by subclassing <code>WebGrammar</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar subclass: #WebParser\n\tinstanceVariableNames: ''\n\tclassVariableNames: ''\n\tpackage: 'PetitParser2-SeasTutorial'</code></pre><figcaption></figcaption></figure>\n\n<p>\nParsing is great use case for test driven development. \nIf you made it so far, you probably mean it with parsing.\nSo let us abandon on a totorial friendly mode and do it the proper way:\nstart with tests. \nActually, they give us a clear idea what kind of interface do we expect from our abstract syntax tree:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammarTest subclass: #WebParserTest\n\tinstanceVariableNames: ''\n\tclassVariableNames: ''\n\tpackage: 'PetitParser2-SeasTutorial'\n\nWebParserTest&gt;&gt;parserClass\n\t^ WebParser\n\nWebParserTest&gt;&gt;testElement\n\tsuper testElement.\n\t\n\tself assert: result name equals: 'p'.\n\tself assert: result firstChild text equals: 'lorem ipsum'\n\nWebParserTest&gt;&gt;testElementEmpty\n\tsuper testElementEmpty.\n\t\n\tself assert: result name equals: 'foo'.\n\nWebParserTest&gt;&gt;testElementNested\n\tsuper testElementNested.\n\t\n\tself assert: result name equals: 'p'.\n\tself assert: result firstChild text trim equals: 'lorem'.\n\tself assert: result secondChild name equals: 'i'.\n\tself assert: result secondChild firstChild text equals: 'ipsum'</code></pre><figcaption></figcaption></figure>\n\n<p>\nAnd for malformed elements, we expect the following results:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testElementMalformed\n\tsuper testElementMalformed.\n\t\n\tself assert: result name equals: 'foo'.\n\tself assert: result firstChild text equals: '&lt;bar&gt;meh&lt;/baz&gt;'\n\nWebParserTest&gt;&gt;testElementMalformedExtraClose\n\tsuper testElementMalformedExtraClose.\n\t\n\tself assert: result name equals: 'foo'.\n\tself assert: result secondChild text equals: '&lt;/fii&gt;'\n\nWebParserTest&gt;&gt;testElementMalformedUnclosed\n\tsuper testElementMalformedUnclosed.\n\t\n\tself assert: result name equals: 'head'.\n\tself assert: result firstChild text trim equals: '&lt;meta content=&quot;mess&quot;&gt;'\n\nWebParserTest&gt;&gt;testElementMalformedWrongClose\n\tsuper testElementMalformedWrongClose.\n\t\n\tself assert: result name equals: 'foo'.\n\tself assert: result firstChild text equals: '&lt;bar&gt;meh&lt;/baz&gt;'</code></pre><figcaption></figcaption></figure>\n\n\n\n<p>\nAnd of course, we expect javascript code to be extracted as follows:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testJavascript\n\tsuper testJavascript.\n\t\n\tself assert: result code equals: 'alert(1+2)'\n\nWebParserTest&gt;&gt;testJavascriptWithString\n\tsuper testJavascriptWithString.\n\t\n\tself assert: result code equals: 'alert(''&lt;/script&gt;'')'</code></pre><figcaption></figcaption></figure>\n\n\n\n<p>\nIf we want to pass these test, the result of a parse should be a tree consisting of three different nodes: \n</p><ol><li>an html element </li>\n<li>a javascript code and </li>\n<li>a text</li>\n</ol>\n<p>\nWe define these nodes as follows, starting with its abstract predecessor <code>WebElement</code>:\n</p>\n\n<figure><pre><code class=\"smalltalk\">Object subclass: #WebElement\n\tinstanceVariableNames: ''\n\tclassVariableNames: ''\n\tpackage: 'PetitParser2-SeasTutorial'\n\nWebElement&gt;&gt;children\n\t^ #()\n\nWebElement&gt;&gt;firstChild\n\t&quot;Just for convenience&quot;\n\t^ self children first\n\nWebElement&gt;&gt;secondChild\n\t&quot;Just for convenience&quot;\n\t^ self children second\n\nWebElement&gt;&gt;gtTreeViewIn: composite\n\t&lt;gtInspectorPresentationOrder: 40&gt;\n\n\tcomposite tree\n\t\ttitle: 'Tree';\n\t\tchildren: [:n | n children ];\n\t\tformat: [:n| n displayText printStringLimitedTo: 50 ];\n\t\tshouldExpandToLevel: 6</code></pre><figcaption></figcaption></figure>\n\n\n<p>\n<code>HtmlElement</code> follows:\n</p>\n<figure><pre><code class=\"smalltalk\">WebElement subclass: #HtmlElement\n\tinstanceVariableNames: 'name children'\n\tclassVariableNames: ''\n\tpackage: 'PetitParser2-SeasTutorial'\n\nHtmlElement&gt;&gt;children\n\t^ children\n\nchildren: anObject\n\tchildren := anObject\n\nname\n\t^ name\n\nname: newName\n\tname := newName\n\t\ndisplayText\n\t^ self name</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nAs well as <code>UnknownText</code>:\n</p><figure><pre><code class=\"smalltalk\">WebElement subclass: #UnknownText\n\tinstanceVariableNames: 'text'\n\tclassVariableNames: ''\n\tpackage: 'PetitParser2-SeasTutorial'\n\n\nUnknownText&gt;&gt;text\n\t^ text\n\nUnknownText&gt;&gt;text: anObject\n\ttext := anObject\n\nUnknownText&gt;&gt;displayText\n\t^ self text trim\n\nUnknownText&gt;&gt;gtText: composite\n\t&lt;gtInspectorPresentationOrder: 40&gt;\n\t\n\tcomposite text\n\t\ttitle: 'Text';\n\t\tdisplay: [ :context | text ]</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nLast but not least there is <code>JavascriptElement</code>:\n</p><figure><pre><code class=\"smalltalk\">WebElement subclass: #JavascriptElement\n\tinstanceVariableNames: 'code'\n\tclassVariableNames: ''\n\tpackage: 'PetitParser2-SeasTutorial'\n\nJavascriptElement&gt;&gt;code\n\t^ code\n\nJavascriptElement&gt;&gt;code: anObject\n\tcode := anObject\n\nJavascriptElement&gt;&gt;displayText\n\t^ self code\n\nJavascriptElement&gt;&gt;gtText: composite\n\t&lt;gtInspectorPresentationOrder: 40&gt;\n\t\n\tcomposite text\n\t\ttitle: 'Text';\n\t\tdisplay: [ :context | code ]</code></pre><figcaption></figcaption></figure>\n\n<p>\nNow we use <code>WebParser</code> to update the <code>javascript</code> rule, to return <code>JavascriptElement</code>, the <code>element</code> rule to return <code>HtmlElement</code> and the <code>text</code> rule to return <code>UnknownText</code>:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParser&gt;&gt;javascript\n\t^ super javascript \n\t\n\tmap: [ :_open :_content :_close | \n\t \t(JavascriptElement new)\n\t\t\tcode: _content;\n\t\t\tyourself\n\t]\n\nWebParser&gt;&gt;element\n\t^ super element \n\t\n\tmap: [ :_open :_content :_close | \n\t \t(HtmlElement new)\n\t\t\tname: _open;\n\t\t\tchildren: _content;\n\t\t\tyourself\n\t]\n\nWebParser&gt;&gt;text\n\t^ super text \n\t\n\tmap: [ :_value | \n\t\tUnknownText new\n\t\t\ttext: _value;\n\t\t\tyourself\t\n\t]</code></pre><figcaption></figcaption></figure>\n\n<p>\nAnd finally, for convenience, we trim whitespaces around html elements:\n</p>\n\n<figure><pre><code class=\"smalltalk\">WebParser&gt;&gt;elClose\n\t^ super elClose trimLeft\n\nWebParser&gt;&gt;elOpen\n\t^ super elOpen trimRight</code></pre><figcaption></figcaption></figure>\n<p class=\"todo\">there is no <code>trimLeft</code> in the source code, fix it...</p>\n</section><section>\n<h2>III. Structured Document</h2>\n\n<p>\nWe defined document in <code>WebGrammar</code> as a repetition of javascript seas. \nNow we define structured document, i.e. a document with an html structure. \nThe root of an html file is an element that can be surrounded by some other information (e.g. doctype or comments), therefore we define it as sea:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;structuredDocument\n\t^ element sea\n\nWebGrammar&gt;&gt;start\n\t^ structuredDocument</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nAnd we should write tests for this:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammarTest&gt;&gt;testStructuredDocument\n\t| input |\n\tinput := '&lt;html&gt;\n\t\t&lt;body&gt;\n\t\t\t&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;hello world&quot;)&lt;/script&gt;\n\t\t&lt;/body&gt;\n\t&lt;/html&gt;'.\n\t\n\tself parse: input rule: #structuredDocument\n\nWebGrammarTest&gt;&gt;testStructuredDocumentWithDoctype\n\t| input |\n\tinput := '\n&lt;!DOCTYPE html&gt;\n&lt;!-- comment --&gt;\n&lt;html&gt;\n\t&lt;meta content=&quot;origin&quot; name=&quot;referrer&quot;&gt;\n\n\n\t&lt;body&gt;\n\t\t&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;hello world&quot;)&lt;/script&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;'.\n\t\n\tself parse: input rule: #structuredDocument</code></pre><figcaption></figcaption></figure>\n\n\n\n<p>\nWe create a root element from the structured document:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParser&gt;&gt;structuredDocument\n\t^ super structuredDocument\n\t\n\tmap: [ :_bw :_document :_aw |\n\t\t| beforeWater afterWater |\n\t\tbeforeWater := UnknownText new\n\t\t\ttext: _bw;\n\t\t\tyourself.\n\t\t\t\n\t\tafterWater := UnknownText new\n\t\t\ttext: _aw;\n\t\t\tyourself.\n\t\t\t\n\t\tHtmlElement new\n\t\t\tname: 'DOCUMENT';\n\t\t\tchildren: (Array with: beforeWater \n\t\t\t\t\t with: _document \n\t\t\t\t\t with: afterWater);\n\t\t\tyourself\n\t\n\t]</code></pre><figcaption></figcaption></figure>\n\n<p>\nAnd we cover the rule with a test:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testStructuredDocument\n\t| html |\n\tsuper testStructuredDocument.\n\t\n\tself assert: result name equals: 'DOCUMENT'.\n\n\n\thtml := result secondChild.\n\tself assert: html name equals: 'html'.\n\n\n\tself assert: html firstChild name equals: 'head'.\t\n\tself assert: html secondChild name equals: 'body'.</code></pre><figcaption></figcaption></figure>\n\n</section><section>\n<h2>IV. Comments</h2>\n\n<p>\nIn this section we focus a bit more how to handle comments. They may contain scripts or other elements and they may confuse the parser. \nActually this is happening in <code>WebParser</code>, which extracts one element that is not in the HTML. Inspect the following and switch to the tree view:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParser new parse: input.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThere is a <em>&lt;p&gt;</em> element in the <em>&lt;body&gt;</em>. \nBut <em>&lt;p&gt;</em> is a part of comment, it should not be included in the document structure. \nWe write a test to cover this:\n</p>\n<figure><pre><code class=\"smalltalk\">WebParserTest&gt;&gt;testStructuredDocument\n\t| html |\n\tsuper testStructuredDocument.\n\t\n\tself assert: result name equals: 'DOCUMENT'.\n\n\thtml := result secondChild.\n\tself assert: html name equals: 'html'.\n\n\tself assert: html firstChild name equals: 'head'.\t\n\tself assert: html secondChild name equals: 'body'.\n\n\tbody := html secondChild.\n\tself assert: body children size equals: 4.</code></pre><figcaption></figcaption></figure>\n\n<p>\nThe problem is, as in the case of prematurely ended javascript, that our parser has no notion of a comment and handles a content of comment as an ordinary html code. \nTherefore we define what is an html comment:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;comment\n\t^ '&lt;!--' asPParser, #any asPParser starLazy, '--&gt;' asPParser</code></pre><figcaption></figcaption></figure>\n\n<p>\nAnd now we can redefine <code>text</code> so that it knows what is a comment:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;text\n\t^ (comment / #any asPParser) starLazy</code></pre><figcaption></figcaption></figure>\n\n<p>\nWe already mentioned in the previous text that <code>starLazy</code> utilizes bounded seas and the above code is equivalent to:\n</p>\n<figure><pre><code class=\"smalltalk\">(#epsilon asPParser)\n  waterToken: (comment / #any asPParser);\n  yourself\t </code></pre><figcaption></figcaption></figure>\n\n\n<p>\nBecause now water knows what is a comment, it skips the complete comment including the <em>&lt;p&gt;</em> element inside.\n</p>\n\n<p>\nThis is it. \nYour tests are passing right now.\n\n</p></section></section>","title":"PetitParser2 and Bounded Seas","Author":"Jan Kurs"}