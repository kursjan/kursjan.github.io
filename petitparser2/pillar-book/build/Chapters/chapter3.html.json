{"content":"<a id=\"top\"></a>\n<p>\nThis text is part of the <a href=\"Chapters/../../book.html\">Parsing With PetitParser2</a> series.\nThe <a href=\"#toc\">table of content</a> can be found at the end of the chapter.\n\n</p>\n<section>\n<h1>Extracting the Structure</h1>\n<a id=\"sec:structure\"></a>\n<p>\nIn the previous chapters we created a parser to extract javascript from HTML source.\nBut our parser is rather simple. \nIt sees an input as a list of javascripts.\nIn this part we extend the parser and we extract the HTML structure. \nAgain, we use bounded seas to ease our task.\nBounded seas become handy when skipping a text in html elements and when recoverring from unclosed or malformed elements.\n</p>\n\n\n\n<section>\n<h2>1. Matching Open And Close Tags</h2>\n\n<p>\nElements of HTML has an interesting property: the name of an opening tag has to match the name of a closing tag. \nThough natural for humans, this is, surprisingly, rather difficult task from the parsing theory point of view.\n</p>\n<p>\nUnfortunately, standard solutions do not fit well into the PetitParser. \nWe describe problem in more details in the supplementary <a href=\"../matchingTags.html\">Matching Tags</a> chapter.\n</p>\n<p>\nPetitParser2 comes with a special syntax to express constrains of matching open and close tags.\nIt can store a result of a rule (e.g. in the rule opening an html tag) onto a stack using the push operator and assert that the result of a rule (e.g. in the rule closing an html tag) matches the top of the stack using the match operator and finally pop the result using the pop operator (after an html tag is sucessfully recognized). \n</p>\n<p>\nHere is the concrete example:\nFirst we define an element name as a repetition of letters and digits:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;elementName\n\t^ #word asPParser plus flatten</code></pre><figcaption></figcaption></figure>\n\n<p>\nThan we define element as a sequence of <code>elOpen</code>, <code>elContent</code> and <code>elClose</code>:\n</p>\n\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;element\n\t^ (elOpen, elContent, elClose)</code></pre><figcaption></figcaption></figure>\n\n<p>\nIn <code>elOpen</code>, we push the element name as well as we consume water in case an element contains arguments:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;elOpen\n\t^ $&lt; asPParser, elementName push, #any asPParser starLazy, $&gt; asPParser ==&gt; #second</code></pre><figcaption></figcaption></figure>\n\n<p>\nIn <code>elClose</code>, we first match the element name against the top of a stack and we pop the stack in case of success:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;elClose\n\t^ '&lt;/' asPParser, elementName match pop, $&gt; asPParser</code></pre><figcaption></figcaption></figure>\n\n</section><section>\n<h2>2. Element Content</h2>\n<p>\nNow we need to define <code>elContent</code> rule, which represents the content of an element. \n<code>elContent</code> is zero or more repetitions of the following components in the given order: \n</p><ol><li>a javascript code, </li>\n<li>another element or </li>\n<li>an unknown text. </li>\n</ol>\n<p>\nWe add javascript to the first position because it is <em>kind of</em> an element and therefore must be ordered first to take precedence. \nThe same goes for an element, it is also <em>kind of</em> a text. \n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;elContent\n\t^ (javascript / element / text nonEpsilon) star</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nText can be anything.\nTherefore, we define it as with the help of bounded seas:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammar&gt;&gt;text\n\t^ #any starLazy</code></pre><figcaption></figcaption></figure>\n\n\n<section>\n<h3>Epsilon in Repetitions</h3>\n<p>\nNote, we mark text as <code>nonEpsilon</code>.\n<code>nonEpsilon</code> operator is an extension of PEGs that allows only for non-empty parses. \nThe reason for this is that <code>#any asPParser starLazy</code> can consume anything, even the empty string. \nThe star repetition of <code>elContent</code> would end up in an infinite loop recognizing an epsilon in each of its iterations, never failing, never stopping.\n</p>\n</section></section><section>\n<h2>3. Testing the Code</h2>\n<p>\nWe have defined a lots of code. Let us try, if it works. \nWe start with <code>text</code>:\n</p>\n\n<figure><pre><code class=\"smalltalk\">WebGrammarTest&gt;&gt;testText\n\tself parse: 'foobar' rule: #text</code></pre><figcaption></figcaption></figure>\n\n\n<p>\nAnd <code>element</code> follows:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammarTest&gt;&gt;testElementEmpty\n\tself parse: '&lt;foo&gt;&lt;/foo&gt;' rule: #element\n[PASS]\n\nWebGrammarTest&gt;&gt;testElement\n\tself parse: '&lt;p&gt;lorem ipsum&lt;/p&gt;' rule: #element\n[PASS]\n\nWebGrammarTest&gt;&gt;testElementNested\n\tself parse: '&lt;p&gt;lorem &lt;i&gt;ipsum&lt;/i&gt;&lt;/p&gt;' rule: #element\n[PASS]</code></pre><figcaption></figcaption></figure>\n\n<p>\nWe should be able to parse malformed elements as well. \nLets see if the <code>push</code>, <code>match</code>, <code>pop</code> magic works, as expected:\n</p>\n<figure><pre><code class=\"smalltalk\">WebGrammarTest&gt;&gt;testElementMalformedWrongClose\n\tself parse: '&lt;foo&gt;&lt;bar&gt;meh&lt;/baz&gt;&lt;/foo&gt;' rule: #element.\n[PASS]\n\nWebGrammarTest&gt;&gt;testElementMalformedExtraClose\n\tself parse: '&lt;foo&gt;&lt;bar&gt;meh&lt;/bar&gt;&lt;/fii&gt;&lt;/foo&gt;' rule: #element\n[PASS]\n\nWebGrammarTest&gt;&gt;testElementMalformedUnclosed\n\tself parse: '&lt;head&gt;&lt;meta content=&quot;mess&quot;&gt;&lt;/head&gt;' rule: #element.\n[PASS]</code></pre><figcaption></figcaption></figure>\n\n</section><section>\n<h2>4. Conclusion</h2>\n\n<p>\nSo far it looks good. \nBut our tests are telling us only that element can parse the given input, it does not tell us how it parses the input. \nWe should assert that the proper element names and the right content is extracted. \n</p>\n\n<p>\nIt is the time to return a more convenient representation of the input: <em>an abstract syntax tree</em>.\nWe will do this in the <a href=\"AST.html\">following chapter</a>.\n\n</p></section></section>","title":"Parsing with PetitParser2","Author":"Jan Kurs"}