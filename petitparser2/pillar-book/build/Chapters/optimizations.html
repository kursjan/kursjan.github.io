<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Parsing with PetitParser2</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Highlight js -->
    <link rel="stylesheet" href="../support/html/highlightjs/styles/default.css">
    <link rel="stylesheet" href="../support/html/css/highlight-commands.css">
    <script src="../support/html/highlightjs/highlight.pack.js"></script>
    <script src="../support/html/js/highlight-commands.js"></script>

    <!-- Bootstrap -->
    <link href="../support/html/css/bootstrap.min.css" rel="stylesheet">
    <link href="../support/html/css/bootstrap-theme.min.css" rel="stylesheet">
    <link href="../support/html/css/square-braket-associates.css" rel="stylesheet">
    <style>
/*        .container { max-width: 55em; } */
    </style>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container text-justify">
      <section>
        <h1>Parsing with PetitParser2</h1>
        <div class="attribution"></div>

        <p>
This text is part of the <a href="Chapters/../../book.html">Parsing With PetitParser2</a> series.
The whole table of content can be found <a href="#toc">at the end of the chapter</a>

</p>
<section>
<h1>Optimizations Overview</h1>


<p class="note">Please note that the <code>WebGrammar</code> exported in the previous chapter contains already optimized version of <code>element</code> rule. In this and the following chapter, we suppose what we stated in <a href="chapter3.html">Extracting the Structure</a> chapter about the <code>element</code> definition, i.e. it looks like this:</p><figure><pre><code class="smalltalk">WebGrammar&gt;&gt;element
	^ (elOpen, elContent, elClose)</code></pre><figcaption></figcaption></figure>


<section>
<h2>1. Basic Analysis</h2>
<p>
When running the <code>testStructuredDocument</code>, you might have noticed that the performance is not good. 
It is actually terribly bad. Let us inspect in in detail:
</p>
<figure><pre><code class="smalltalk">input := PP2Sources current htmlSample.
WebParser new debug: input.</code></pre><figcaption></figcaption></figure>

<section>
<h3>Report View</h3>
<p>
This will run the parser in a debug mode, which collects lots of useful information. Unfortunately, it also takes considerable amount of time so be patient. Once you get the result, inspect the Report tab (note that numbers might slightly differ in your case):
</p>
<p>

<figure>
	<img src="figures/unoptimized-report.png" width="100%%"/>
	<figcaption></figcaption>
</figure>
</p>
<p>
The total stream size is 1171 characters. 
The parser has remembered the full context 510197 times and restored 387667 times. 
This means that the full copy of the context (including the stack of opened elements) has been created 510197 times and the context has been restored from this full copy (by doing another copy) 387667 times. 
This is in average 331 backtrackings per consumed character. 
</p>

<p>
Some of the parsers do not need to perform the full context copy. 
These are prefixed with ‘lightweight’. 
In the lightweight case, only the position is remembered and restored (which is much faster than the full copy of a stack). 
This happened in average 92 times per character.
</p>

<p>
Honestly, these numbers are brutal. 
In ideal case, the number of full restores should be zero. 
Full remember and restore is very expensive. 
Very often only lightweight remember and restore happens, since many grammars are context-free, i.e. they do not use <code>push</code>, <code>match</code> and <code>pop</code> operators. 
</p>
<p>
Regarding the lightweight backtracking, the average of lightweight backtracks per character should be below 1 (in ideal case). 
This can happen in rase of deterministic grammars, which do not do any (or only a little) speculations and know exactly which alternative of a choice is the correct one. 
</p>
</section><section>
<h3>Debug View</h3>
<p>
So why are the numbers so bad in our case? Let us inspect in more detail how this was happening, using the Debug view:
</p>
<p>

<figure>
	<img src="figures/unoptimized-debug.png" width="100%%"/>
	<figcaption></figcaption>
</figure>
</p>
<p>
The view shows us that 1502165 parsers were invoked to consume the input. 
Most of it (751559 invocations) happened when parsing first two lines of the input - the before water of the sea.
</p>
<p>
This is too much for such a short input. 
Such a bad performance is caused by the fact that bounded seas have to verify at every position if the next parser can be parsed. 
If the next parser happens to be another sea (as in the case of <code>WebGrammar</code>), the number of invocations grows really fast (exponentially in fact). 
</p>

<p>
We see that the element rule took approximately one half of the invocations (750598). 
Majority of 751559 invocations of before water were spent by testing for element. 
</p>
<p>
Another glimpse of ineffectivness can be seen in the <code>elOpen</code> rule.
</p>
<p>
<a id="elOpenUnoptimized"></a>
<figure>
	<img src="figures/unoptimized-elOpen.png" width="100%%"/>
	<figcaption>0.1. </figcaption>
</figure>
</p>
<p>
You can see that the whole <em>&lt;html lang=&quot;html&quot; dir=&quot;ltr&quot; class=&quot;js-enabled&quot;&gt;</em> is parsed by invoking 272 parsers.
This is rather too much for a line with 55 characters.
One of the reasons is how are the identifiers parsed.
You can see that when recognizing the <em>html</em> text, 6 different parsers are invoked; for each letter one and two extra parsers.
</p>
</section></section><section>
<h2>2. Using the <code>optimize</code> method</h2>
<p>
Luckily, PetitParser2 comes with an automated optimizations that are able to reduce most of the unnecessary overhead. 
Let it give a try:
</p>
<figure><pre><code class="smalltalk">WebParser new optimize debug: input.</code></pre><figcaption></figcaption></figure>

<p>
The report looks much better now:

<figure>
	<img src="figures/optimized-report.png" width="100%%"/>
	<figcaption></figcaption>
</figure>
</p>


<p>
Only one full remember, and only 7 lightweight backtracks per character. 
This is reasonably good for a grammar with bounded seas. 
</p>
<p class="note">Because of the nature of bounded seas and implementation of PetitParser2, we do not recommend to parse grammars with more complicated bounded seas without optimizations.</p>
<section>
<h3>Optimization in Detail</h3>
<p>
Let us inspect some of the optimizations that happened. 
Let us try the Debug view:
</p>
<p>

<figure>
	<img src="figures/optimized-debug.png" width="100%%"/>
	<figcaption></figcaption>
</figure>
</p>
<p>
We see that the total number of invoked parsers is 55144, roughly 30x less. 
We also see that, as in the previous case, most of the parsers were invoked in the before-water of the initial sea, even though roughly 10x less. 
But we can also notice that the following island and after water are parsed using only 2 and 4 parser invocations respectively! 
</p>
</section><section>
<h3>Caches</h3>

<p>
The main reason of reduced invocations is caching. 
Under the <code>element</code> rule, there is a mapping node. 
The mapping node returns the complete HTML element just in two invocations. 
The fact that the result has been cached is visualized via the result reference. 
</p>

<p>
The reference indicates that at the time of that invocation the result has already been computed during some previous invocation. 
The parser remembered it and it returned the result without invoking the parser again. 
This is done by the <code>PP2Cache</code> strategy (you can see its profiling version in the screenshot). The cache has been added to the element during the optimization phase. 
</p>

</section><section>
<h3>Specializations</h3>

<p>
Another optimizations applied by PetitParser two are specializations.
The way specializations work can be demonstrated on the opening of an html element: <em>&lt;html lang=&quot;mul&quot; dir=&quot;ltr&quot; class=&quot;js-enabled&quot;&gt;</em>.
</p>
<p>
<a id="elOpenOptimized"></a>
<figure>
	<img src="figures/optimized-elOpen.png" width="100%%"/>
	<figcaption>0.2. Optimized parse of <code>elOpen</code></figcaption>
</figure>
</p>
<p>
One can see that the <em>html</em> text has been recognized using only one invocation contrary to the six invocations in the unoptimized case (see Figure <a href="#elOpenUnoptimized">0.1</a>).
In the unoptimized case the <em>html</em> text was parsed using the <em>PossessiveRepeating</em> strategy.
In the optimized case (see Figure <a href="#elOpenOptimized">0.2</a>) the used strategy is <em>PlusPredicateObject</em>, which is implemented as a while loop without underlying parser invocations hence is more efficient.
</p>
<p>
The same thing happened with the mapping node. 
The specializations recognized an <em>any-star-lazy</em> pattern, which, in this case, means to consume any character until end of the tag <code>&gt;</code> appears.
This can be implemented as a single while loop saving 252 parser invocations.
</p>
<p>
We investigate these optimizations in more details in these chapters:
</p><ul>
<li>Specializations are described in detail in the <a href="smalltalkOptimizations.html">Smalltalk Parser</a> chapter</li>
<li>Caches are described in more detail in the <a href="Cacheds in Detail"></a> chapter</li>
</ul>

</section></section><section>
<h2>3. Specializations</h2>
<p>
The nature of <code>WebGrammar</code> profits mostly from caching optimizations, therefore we describe them in detail in this text.
</p>
<p>
Nevertheless, for other grammars, specializations of PetitParser2 significantly speeds up the parser's execution.
We investigate specializations in more details in the <a href="smalltalkOptimizations.html">Smalltalk Parser</a> chapter.
</p>
<p class="todo">create text about optimization of SmalltalkParser + comparsion with SmaCC.</p>

</section><section>
<h2>4. Conclusion</h2>
<p>
In this text we briefly described how inefficiencies of PEG-based parser combinators and we showed how can the <code>optimize</code> method fix most of these.
</p>
<p>
Unfortunatelly, not all the optimizations can be done automatically.
You might have noticed that we described only three out of four different caches used in the PetitParser. 
The last fourth cache is a bit special and we will dedicate a whole <a href="memoization.html">Memoization</a> chapter to it.
</p>
<a id="toc"></a><section>
<h1>Table of Contents</h1>
<p>
This text is part of the <a href="Chapters/../../book.html">Parsing With PetitParser2</a> series.
</p>
<p>
Part I, Basics:
</p><ul>
<li><a href="Chapters/../chapter1.html">Extracting Javascript</a></li>
<li><a href="Chapters/../chapter2.html">From Script to Parser</a></li>
<li><a href="Chapters/../chapter3.html">Extracting the Structure</a></li>
<li><a href="Chapters/../AST.html">Abstract Syntax Tree</a></li>
<li><a href="Chapters/../optimizations.html">Optimizations</a></li>
<li><a href="Chapters/../memoization.html">Memoization</a></li>
</ul>

<p>
Part II, Advanced Topics:
</p><ul>
<li><a href="Chapters/../matchingTags.html">Matching Tags</a></li>
<li><a href="Chapters/../smalltalkOptimization.html">Specializations in Detail</a></li>
<li><a href="Chapters/../caches.html">Caches in Detail</a></li>
</ul>
</section></section></section>
      </section>
    </div>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://code.jquery.com/jquery.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="../support/html/js/bootstrap.min.js"></script>

    <!-- Syntax highlighting of code blocks -->
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- Prettify annotated paragraphs-->
    <script src="../support/html/js/annotated-paragraphs.js"></script>

  </body>
</html>
